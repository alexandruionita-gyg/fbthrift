/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "module_types.h"

#include "module_reflection.h"

#include <algorithm>
#include <string.h>

namespace test_cpp1 { namespace cpp_reflection {

const int _kenum1Values[] = {
  field0,
  field1,
  field2
};

const char* const _kenum1Names[] = {
  "field0",
  "field1",
  "field2"
};

const std::map<int, const char*> _enum1_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findName( ::test_cpp1::cpp_reflection::enum1 value) {
return findName( ::test_cpp1::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum1* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum1_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum2Values[] = {
  field0_2,
  field1_2,
  field2_2
};

const char* const _kenum2Names[] = {
  "field0_2",
  "field1_2",
  "field2_2"
};

const std::map<int, const char*> _enum2_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findName( ::test_cpp1::cpp_reflection::enum2 value) {
return findName( ::test_cpp1::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum2* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum2_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
const int _kenum3Values[] = {
  field0_3,
  field1_3,
  field2_3
};

const char* const _kenum3Names[] = {
  "field0_3",
  "field1_3",
  "field2_3"
};

const std::map<int, const char*> _enum3_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findName( ::test_cpp1::cpp_reflection::enum3 value) {
return findName( ::test_cpp1::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::test_cpp1::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp1::cpp_reflection::enum3* out) {
return findValue( ::test_cpp1::cpp_reflection::_enum3_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace test_cpp1 { namespace cpp_reflection {
  void union1::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union1");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui"] != nullptr) {
      set_ui();
      int64_t _tmp0 = (int64_t)parsed["ui"].asInt();
      if (imaxabs(_tmp0) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui = (int32_t)_tmp0;
      }
      return;
    }
    if (parsed["ud"] != nullptr) {
      set_ud();
      this->value_.ud = parsed["ud"].asDouble();
      return;
    }
    if (parsed["us"] != nullptr) {
      set_us();
      this->value_.us = parsed["us"].asString().toStdString();
      return;
    }
    if (parsed["ue"] != nullptr) {
      set_ue();
      this->value_.ue=(enum1)(int32_t)parsed["ue"].asInt();
      return;
    }
  }
  void union1::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union1::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui();
          xfer += iprot->readI32(this->value_.ui);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud();
          xfer += iprot->readDouble(this->value_.ud);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us();
          xfer += iprot->readString(this->value_.us);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue();
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->value_.ue = (enum1)ecast2;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union1");
  switch (type_) {
    case Type::ui: {
      xfer += oprot->writeFieldBegin("ui", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud: {
      xfer += oprot->writeFieldBegin("ud", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us: {
      xfer += oprot->writeFieldBegin("us", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue: {
      xfer += oprot->writeFieldBegin("ue", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union2::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union2");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_2"] != nullptr) {
      set_ui_2();
      int64_t _tmp3 = (int64_t)parsed["ui_2"].asInt();
      if (imaxabs(_tmp3) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_2 = (int32_t)_tmp3;
      }
      return;
    }
    if (parsed["ud_2"] != nullptr) {
      set_ud_2();
      this->value_.ud_2 = parsed["ud_2"].asDouble();
      return;
    }
    if (parsed["us_2"] != nullptr) {
      set_us_2();
      this->value_.us_2 = parsed["us_2"].asString().toStdString();
      return;
    }
    if (parsed["ue_2"] != nullptr) {
      set_ue_2();
      this->value_.ue_2=(enum1)(int32_t)parsed["ue_2"].asInt();
      return;
    }
  }
  void union2::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union2::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_2();
          xfer += iprot->readI32(this->value_.ui_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_2();
          xfer += iprot->readDouble(this->value_.ud_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_2();
          xfer += iprot->readString(this->value_.us_2);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_2();
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->value_.ue_2 = (enum1)ecast5;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union2");
  switch (type_) {
    case Type::ui_2: {
      xfer += oprot->writeFieldBegin("ui_2", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_2: {
      xfer += oprot->writeFieldBegin("ud_2", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_2: {
      xfer += oprot->writeFieldBegin("us_2", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_2: {
      xfer += oprot->writeFieldBegin("ue_2", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_2);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

  void union3::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse union3");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["ui_3"] != nullptr) {
      set_ui_3();
      int64_t _tmp6 = (int64_t)parsed["ui_3"].asInt();
      if (imaxabs(_tmp6) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.ui_3 = (int32_t)_tmp6;
      }
      return;
    }
    if (parsed["ud_3"] != nullptr) {
      set_ud_3();
      this->value_.ud_3 = parsed["ud_3"].asDouble();
      return;
    }
    if (parsed["us_3"] != nullptr) {
      set_us_3();
      this->value_.us_3 = parsed["us_3"].asString().toStdString();
      return;
    }
    if (parsed["ue_3"] != nullptr) {
      set_ue_3();
      this->value_.ue_3=(enum1)(int32_t)parsed["ue_3"].asInt();
      return;
    }
  }
  void union3::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t union3::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ui_3();
          xfer += iprot->readI32(this->value_.ui_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_ud_3();
          xfer += iprot->readDouble(this->value_.ud_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_us_3();
          xfer += iprot->readString(this->value_.us_3);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_ue_3();
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->value_.ue_3 = (enum1)ecast8;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t union3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("union3");
  switch (type_) {
    case Type::ui_3: {
      xfer += oprot->writeFieldBegin("ui_3", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.ui_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ud_3: {
      xfer += oprot->writeFieldBegin("ud_3", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.ud_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::us_3: {
      xfer += oprot->writeFieldBegin("us_3", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.us_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::ue_3: {
      xfer += oprot->writeFieldBegin("ue_3", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.ue_3);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structA::_reflection_id;
void structA::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(schema);
}

bool structA::operator == (const structA & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  return true;
}

void structA::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp10 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp10) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp10;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString().toStdString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
}
void structA::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structA::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_9663308154247018828(*schema);
    iprot->setNextStructType(structA::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structA::__clear() {
  a = 0;
  b = "";
  __isset.__clear();
}
uint32_t structA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structA");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structA &a, structA &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

void merge(const structA& from, structA& to) {
  using apache::thrift::merge;
  if (from.__isset.a) {
    merge(from.a, to.a);
    to.__isset.a = true;
  }
  if (from.__isset.b) {
    merge(from.b, to.b);
    to.__isset.b = true;
  }
}

void merge(structA&& from, structA& to) {
  using apache::thrift::merge;
  if (from.__isset.a) {
    merge(std::move(from.a), to.a);
    to.__isset.a = true;
  }
  if (from.__isset.b) {
    merge(std::move(from.b), to.b);
    to.__isset.b = true;
  }
}

  void unionA::readFromJson(const char* jsonText, size_t len)
  {
    __clear();
    folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
    if (!parsed.isObject() || parsed.size() > 1) {
      throw apache::thrift::TLibraryException("Can't parse unionA");
    }

    if (parsed.empty()) {
      return;
    }

    if (parsed["i"] != nullptr) {
      set_i();
      int64_t _tmp11 = (int64_t)parsed["i"].asInt();
      if (imaxabs(_tmp11) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->value_.i = (int32_t)_tmp11;
      }
      return;
    }
    if (parsed["d"] != nullptr) {
      set_d();
      this->value_.d = parsed["d"].asDouble();
      return;
    }
    if (parsed["s"] != nullptr) {
      set_s();
      this->value_.s = parsed["s"].asString().toStdString();
      return;
    }
    if (parsed["e"] != nullptr) {
      set_e();
      this->value_.e=(enum1)(int32_t)parsed["e"].asInt();
      return;
    }
    if (parsed["a"] != nullptr) {
      set_a();
      this->value_.a.readFromJson(folly::toJson(parsed["a"]).toStdString().c_str());
      return;
    }
  }
  void unionA::readFromJson(const char* jsonText)
  {
    readFromJson(jsonText, strlen(jsonText));
  }

uint32_t unionA::read(apache::thrift::protocol::TProtocol* iprot) {
  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;
  xfer += iprot->readStructBegin(fname);
  xfer += iprot->readFieldBegin(fname, ftype, fid);
  if (ftype == apache::thrift::protocol::T_STOP) {
    __clear();
  } else {
    switch (fid) {
      case 1: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_i();
          xfer += iprot->readI32(this->value_.i);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 2: {
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          set_d();
          xfer += iprot->readDouble(this->value_.d);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 3: {
        if (ftype == apache::thrift::protocol::T_STRING) {
          set_s();
          xfer += iprot->readString(this->value_.s);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 4: {
        if (ftype == apache::thrift::protocol::T_I32) {
          set_e();
          int32_t ecast13;
          xfer += iprot->readI32(ecast13);
          this->value_.e = (enum1)ecast13;
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      case 5: {
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          set_a();
          xfer += this->value_.a.read(iprot);
        } else {
        xfer += iprot->skip(ftype);
        }
        break;
      }
      default: xfer += iprot->skip(ftype); break;
    }
    xfer += iprot->readFieldEnd();
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    xfer += iprot->readFieldEnd();
  }
  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t unionA::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("unionA");
  switch (type_) {
    case Type::i: {
      xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_I32, 1);
      xfer += oprot->writeI32(this->value_.i);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::d: {
      xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_DOUBLE, 2);
      xfer += oprot->writeDouble(this->value_.d);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::s: {
      xfer += oprot->writeFieldBegin("s", apache::thrift::protocol::T_STRING, 3);
      xfer += oprot->writeString(this->value_.s);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::e: {
      xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 4);
      xfer += oprot->writeI32((int32_t)this->value_.e);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::a: {
      xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_STRUCT, 5);
      xfer += this->value_.a.write(oprot);
      xfer += oprot->writeFieldEnd();
      break;
    }
    case Type::__EMPTY__:;
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

const uint64_t structB::_reflection_id;
void structB::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(schema);
}

bool structB::operator == (const structB & rhs) const {
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  return true;
}

void structB::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
}
void structB::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structB::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_10239267202130913964(*schema);
    iprot->setNextStructType(structB::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}
uint32_t structB::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structB");
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structB &a, structB &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

void merge(const structB& from, structB& to) {
  using apache::thrift::merge;
  if (from.__isset.c) {
    merge(from.c, to.c);
    to.__isset.c = true;
  }
  if (from.__isset.d) {
    merge(from.d, to.d);
    to.__isset.d = true;
  }
}

void merge(structB&& from, structB& to) {
  using apache::thrift::merge;
  if (from.__isset.c) {
    merge(std::move(from.c), to.c);
    to.__isset.c = true;
  }
  if (from.__isset.d) {
    merge(std::move(from.d), to.d);
    to.__isset.d = true;
  }
}

const uint64_t structC::_reflection_id;
void structC::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(schema);
}

bool structC::operator == (const structC & rhs) const {
  if (!(this->a == rhs.a))
    return false;
  if (!(this->b == rhs.b))
    return false;
  if (!(this->c == rhs.c))
    return false;
  if (!(this->d == rhs.d))
    return false;
  if (!(this->e == rhs.e))
    return false;
  if (!(this->f == rhs.f))
    return false;
  if (!(this->g == rhs.g))
    return false;
  if (!(this->h == rhs.h))
    return false;
  if (!(this->i == rhs.i))
    return false;
  if (!(this->j == rhs.j))
    return false;
  if (!(this->j1 == rhs.j1))
    return false;
  if (!(this->j2 == rhs.j2))
    return false;
  if (!(this->j3 == rhs.j3))
    return false;
  if (!(this->k == rhs.k))
    return false;
  if (!(this->k1 == rhs.k1))
    return false;
  if (!(this->k2 == rhs.k2))
    return false;
  if (!(this->k3 == rhs.k3))
    return false;
  if (!(this->l == rhs.l))
    return false;
  if (!(this->l1 == rhs.l1))
    return false;
  if (!(this->l2 == rhs.l2))
    return false;
  if (!(this->l3 == rhs.l3))
    return false;
  if (!(this->m1 == rhs.m1))
    return false;
  if (!(this->m2 == rhs.m2))
    return false;
  if (!(this->m3 == rhs.m3))
    return false;
  if (!(this->n1 == rhs.n1))
    return false;
  if (!(this->n2 == rhs.n2))
    return false;
  if (!(this->n3 == rhs.n3))
    return false;
  if (!(this->o1 == rhs.o1))
    return false;
  if (!(this->o2 == rhs.o2))
    return false;
  if (!(this->o3 == rhs.o3))
    return false;
  return true;
}

void structC::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["a"] != nullptr) {
    int64_t _tmp16 = (int64_t)parsed["a"].asInt();
    if (imaxabs(_tmp16) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->a = (int32_t)_tmp16;
    }
    this->__isset.a = true;
  } else {
    this->__isset.a = false;
  }
  if (parsed["b"] != nullptr) {
    this->b = parsed["b"].asString().toStdString();
    this->__isset.b = true;
  } else {
    this->__isset.b = false;
  }
  if (parsed["c"] != nullptr) {
    this->c = parsed["c"].asDouble();
    this->__isset.c = true;
  } else {
    this->__isset.c = false;
  }
  if (parsed["d"] != nullptr) {
    this->d = parsed["d"].asBool();
    this->__isset.d = true;
  } else {
    this->__isset.d = false;
  }
  if (parsed["e"] != nullptr) {
    this->e=(enum1)(int32_t)parsed["e"].asInt();
    this->__isset.e = true;
  } else {
    this->__isset.e = false;
  }
  if (parsed["f"] != nullptr) {
    this->f=(enum2)(int32_t)parsed["f"].asInt();
    this->__isset.f = true;
  } else {
    this->__isset.f = false;
  }
  if (parsed["g"] != nullptr) {
    this->g.readFromJson(folly::toJson(parsed["g"]).toStdString().c_str());
    this->__isset.g = true;
  } else {
    this->__isset.g = false;
  }
  if (parsed["h"] != nullptr) {
    this->h.readFromJson(folly::toJson(parsed["h"]).toStdString().c_str());
    this->__isset.h = true;
  } else {
    this->__isset.h = false;
  }
  if (parsed["i"] != nullptr) {
    this->i.readFromJson(folly::toJson(parsed["i"]).toStdString().c_str());
    this->__isset.i = true;
  } else {
    this->__isset.i = false;
  }
  if (parsed["j"] != nullptr) {
    folly::dynamic _json21 = parsed["j"];
    this->j.clear();
    uint32_t _size19 = _json21.size();
    this->j.resize(_size19);
    for (uint32_t _i20 = 0; _i20 < _size19; ++_i20)
    {
      int64_t _tmp22 = (int64_t)_json21[_i20].asInt();
      if (imaxabs(_tmp22) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j[_i20] = (int32_t)_tmp22;
      }
    }
    this->__isset.j = true;
  } else {
    this->__isset.j = false;
  }
  if (parsed["j1"] != nullptr) {
    folly::dynamic _json25 = parsed["j1"];
    this->j1.clear();
    uint32_t _size23 = _json25.size();
    this->j1.resize(_size23);
    for (uint32_t _i24 = 0; _i24 < _size23; ++_i24)
    {
      int64_t _tmp26 = (int64_t)_json25[_i24].asInt();
      if (imaxabs(_tmp26) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->j1[_i24] = (int32_t)_tmp26;
      }
    }
    this->__isset.j1 = true;
  } else {
    this->__isset.j1 = false;
  }
  if (parsed["j2"] != nullptr) {
    folly::dynamic _json29 = parsed["j2"];
    this->j2.clear();
    uint32_t _size27 = _json29.size();
    this->j2.resize(_size27);
    for (uint32_t _i28 = 0; _i28 < _size27; ++_i28)
    {
      this->j2[_i28]=(enum1)(int32_t)_json29[_i28].asInt();
    }
    this->__isset.j2 = true;
  } else {
    this->__isset.j2 = false;
  }
  if (parsed["j3"] != nullptr) {
    folly::dynamic _json33 = parsed["j3"];
    this->j3.clear();
    uint32_t _size31 = _json33.size();
    this->j3.resize(_size31);
    for (uint32_t _i32 = 0; _i32 < _size31; ++_i32)
    {
      this->j3[_i32].readFromJson(folly::toJson(_json33[_i32]).toStdString().c_str());
    }
    this->__isset.j3 = true;
  } else {
    this->__isset.j3 = false;
  }
  if (parsed["k"] != nullptr) {
    folly::dynamic _json36 = parsed["k"];
    this->k.clear();
    uint32_t _size34 = _json36.size();
    for (uint32_t _i35 = 0; _i35 < _size34; ++_i35)
    {
      int32_t _elem37;
      int64_t _tmp38 = (int64_t)_json36[_i35].asInt();
      if (imaxabs(_tmp38) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem37 = (int32_t)_tmp38;
      }
      this->k.insert(_elem37);
    }
    this->__isset.k = true;
  } else {
    this->__isset.k = false;
  }
  if (parsed["k1"] != nullptr) {
    folly::dynamic _json41 = parsed["k1"];
    this->k1.clear();
    uint32_t _size39 = _json41.size();
    for (uint32_t _i40 = 0; _i40 < _size39; ++_i40)
    {
      int32_t _elem42;
      int64_t _tmp43 = (int64_t)_json41[_i40].asInt();
      if (imaxabs(_tmp43) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem42 = (int32_t)_tmp43;
      }
      this->k1.insert(_elem42);
    }
    this->__isset.k1 = true;
  } else {
    this->__isset.k1 = false;
  }
  if (parsed["k2"] != nullptr) {
    folly::dynamic _json46 = parsed["k2"];
    this->k2.clear();
    uint32_t _size44 = _json46.size();
    for (uint32_t _i45 = 0; _i45 < _size44; ++_i45)
    {
      enum2 _elem47;
      _elem47=(enum2)(int32_t)_json46[_i45].asInt();
      this->k2.insert(_elem47);
    }
    this->__isset.k2 = true;
  } else {
    this->__isset.k2 = false;
  }
  if (parsed["k3"] != nullptr) {
    folly::dynamic _json51 = parsed["k3"];
    this->k3.clear();
    uint32_t _size49 = _json51.size();
    for (uint32_t _i50 = 0; _i50 < _size49; ++_i50)
    {
      structB _elem52;
      _elem52.readFromJson(folly::toJson(_json51[_i50]).toStdString().c_str());
      this->k3.insert(_elem52);
    }
    this->__isset.k3 = true;
  } else {
    this->__isset.k3 = false;
  }
  if (parsed["l"] != nullptr) {
    folly::dynamic _json55 = parsed["l"];
    this->l.clear();
    for (folly::dynamic::const_item_iterator _iter56 = _json55.items().begin(); _iter56 != _json55.items().end(); _iter56++)    {
      int32_t _key57;;
      int32_t _val58;;
      try {
        _key57 = folly::to<int32_t>((_iter56)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp59 = (int64_t)_iter56->second.asInt();
      if (imaxabs(_tmp59) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val58 = (int32_t)_tmp59;
      }
      this->l[_key57] = _val58;
    }
    this->__isset.l = true;
  } else {
    this->__isset.l = false;
  }
  if (parsed["l1"] != nullptr) {
    folly::dynamic _json62 = parsed["l1"];
    this->l1.clear();
    for (folly::dynamic::const_item_iterator _iter63 = _json62.items().begin(); _iter63 != _json62.items().end(); _iter63++)    {
      int32_t _key64;;
      int32_t _val65;;
      try {
        _key64 = folly::to<int32_t>((_iter63)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp66 = (int64_t)_iter63->second.asInt();
      if (imaxabs(_tmp66) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val65 = (int32_t)_tmp66;
      }
      this->l1[_key64] = _val65;
    }
    this->__isset.l1 = true;
  } else {
    this->__isset.l1 = false;
  }
  if (parsed["l2"] != nullptr) {
    folly::dynamic _json69 = parsed["l2"];
    this->l2.clear();
    for (folly::dynamic::const_item_iterator _iter70 = _json69.items().begin(); _iter70 != _json69.items().end(); _iter70++)    {
      int32_t _key71;;
      enum1 _val72;;
      try {
        _key71 = folly::to<int32_t>((_iter70)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val72=(enum1)(int32_t)_iter70->second.asInt();
      this->l2[_key71] = _val72;
    }
    this->__isset.l2 = true;
  } else {
    this->__isset.l2 = false;
  }
  if (parsed["l3"] != nullptr) {
    folly::dynamic _json76 = parsed["l3"];
    this->l3.clear();
    for (folly::dynamic::const_item_iterator _iter77 = _json76.items().begin(); _iter77 != _json76.items().end(); _iter77++)    {
      int32_t _key78;;
      structB _val79;;
      try {
        _key78 = folly::to<int32_t>((_iter77)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val79.readFromJson(folly::toJson(_iter77->second).toStdString().c_str());
      this->l3[_key78] = _val79;
    }
    this->__isset.l3 = true;
  } else {
    this->__isset.l3 = false;
  }
  if (parsed["m1"] != nullptr) {
    folly::dynamic _json82 = parsed["m1"];
    this->m1.clear();
    for (folly::dynamic::const_item_iterator _iter83 = _json82.items().begin(); _iter83 != _json82.items().end(); _iter83++)    {
      enum1 _key84;;
      int32_t _val85;;
      try {
        _key84 = (enum1)folly::to<int>((_iter83)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      int64_t _tmp86 = (int64_t)_iter83->second.asInt();
      if (imaxabs(_tmp86) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val85 = (int32_t)_tmp86;
      }
      this->m1[_key84] = _val85;
    }
    this->__isset.m1 = true;
  } else {
    this->__isset.m1 = false;
  }
  if (parsed["m2"] != nullptr) {
    folly::dynamic _json89 = parsed["m2"];
    this->m2.clear();
    for (folly::dynamic::const_item_iterator _iter90 = _json89.items().begin(); _iter90 != _json89.items().end(); _iter90++)    {
      enum1 _key91;;
      enum2 _val92;;
      try {
        _key91 = (enum1)folly::to<int>((_iter90)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val92=(enum2)(int32_t)_iter90->second.asInt();
      this->m2[_key91] = _val92;
    }
    this->__isset.m2 = true;
  } else {
    this->__isset.m2 = false;
  }
  if (parsed["m3"] != nullptr) {
    folly::dynamic _json96 = parsed["m3"];
    this->m3.clear();
    for (folly::dynamic::const_item_iterator _iter97 = _json96.items().begin(); _iter97 != _json96.items().end(); _iter97++)    {
      enum1 _key98;;
      structB _val99;;
      try {
        _key98 = (enum1)folly::to<int>((_iter97)->first.asString().toStdString());
      } catch (std::range_error& ex) {
        throw apache::thrift::TLibraryException(ex.what());
      }
      _val99.readFromJson(folly::toJson(_iter97->second).toStdString().c_str());
      this->m3[_key98] = _val99;
    }
    this->__isset.m3 = true;
  } else {
    this->__isset.m3 = false;
  }
  if (parsed["n1"] != nullptr) {
    folly::dynamic _json102 = parsed["n1"];
    this->n1.clear();
    for (folly::dynamic::const_item_iterator _iter103 = _json102.items().begin(); _iter103 != _json102.items().end(); _iter103++)    {
      std::string _key104;;
      int32_t _val105;;
      _key104 = (_iter103)->first.asString().toStdString();
      int64_t _tmp106 = (int64_t)_iter103->second.asInt();
      if (imaxabs(_tmp106) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _val105 = (int32_t)_tmp106;
      }
      this->n1[_key104] = _val105;
    }
    this->__isset.n1 = true;
  } else {
    this->__isset.n1 = false;
  }
  if (parsed["n2"] != nullptr) {
    folly::dynamic _json109 = parsed["n2"];
    this->n2.clear();
    for (folly::dynamic::const_item_iterator _iter110 = _json109.items().begin(); _iter110 != _json109.items().end(); _iter110++)    {
      std::string _key111;;
      enum1 _val112;;
      _key111 = (_iter110)->first.asString().toStdString();
      _val112=(enum1)(int32_t)_iter110->second.asInt();
      this->n2[_key111] = _val112;
    }
    this->__isset.n2 = true;
  } else {
    this->__isset.n2 = false;
  }
  if (parsed["n3"] != nullptr) {
    folly::dynamic _json116 = parsed["n3"];
    this->n3.clear();
    for (folly::dynamic::const_item_iterator _iter117 = _json116.items().begin(); _iter117 != _json116.items().end(); _iter117++)    {
      std::string _key118;;
      structB _val119;;
      _key118 = (_iter117)->first.asString().toStdString();
      _val119.readFromJson(folly::toJson(_iter117->second).toStdString().c_str());
      this->n3[_key118] = _val119;
    }
    this->__isset.n3 = true;
  } else {
    this->__isset.n3 = false;
  }
  if (parsed["o1"] != nullptr) {
    this->__isset.o1 = true;
  } else {
    this->__isset.o1 = false;
  }
  if (parsed["o2"] != nullptr) {
    this->__isset.o2 = true;
  } else {
    this->__isset.o2 = false;
  }
  if (parsed["o3"] != nullptr) {
    this->__isset.o3 = true;
  } else {
    this->__isset.o3 = false;
  }
}
void structC::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t structC::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18130273386912691148(*schema);
    iprot->setNextStructType(structC::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;



  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast129;
          xfer += iprot->readI32(ecast129);
          this->e = (enum1)ecast129;
          this->__isset.e = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          this->f = (enum2)ecast130;
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->g.read(iprot);
          this->__isset.g = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->h.read(iprot);
          this->__isset.h = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->i.read(iprot);
          this->__isset.i = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j.clear();
            uint32_t _size131;
            bool _sizeUnknown132;
            apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size131, _sizeUnknown132);
            if (!_sizeUnknown132) {
              this->j.resize(_size131);
              uint32_t _i136;
              for (_i136 = 0; _i136 < _size131; ++_i136)
              {
                xfer += iprot->readI32(this->j[_i136]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem137;
                xfer += iprot->readI32(_elem137);
                this->j.push_back(_elem137);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j1.clear();
            uint32_t _size138;
            bool _sizeUnknown139;
            apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size138, _sizeUnknown139);
            if (!_sizeUnknown139) {
              this->j1.resize(_size138);
              uint32_t _i143;
              for (_i143 = 0; _i143 < _size138; ++_i143)
              {
                xfer += iprot->readI32(this->j1[_i143]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem144;
                xfer += iprot->readI32(_elem144);
                this->j1.push_back(_elem144);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j2.clear();
            uint32_t _size145;
            bool _sizeUnknown146;
            apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size145, _sizeUnknown146);
            if (!_sizeUnknown146) {
              this->j2.resize(_size145);
              uint32_t _i150;
              for (_i150 = 0; _i150 < _size145; ++_i150)
              {
                int32_t ecast151;
                xfer += iprot->readI32(ecast151);
                this->j2[_i150] = (enum1)ecast151;
              }
            } else {
              while (iprot->peekList())
              {
                enum1 _elem152;
                int32_t ecast153;
                xfer += iprot->readI32(ecast153);
                _elem152 = (enum1)ecast153;
                this->j2.push_back(_elem152);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->j3.clear();
            uint32_t _size154;
            bool _sizeUnknown155;
            apache::thrift::protocol::TType _etype158;
            xfer += iprot->readListBegin(_etype158, _size154, _sizeUnknown155);
            if (!_sizeUnknown155) {
              this->j3.resize(_size154);
              uint32_t _i159;
              for (_i159 = 0; _i159 < _size154; ++_i159)
              {
                xfer += this->j3[_i159].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem160;
                xfer += _elem160.read(iprot);
                this->j3.push_back(_elem160);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.j3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k.clear();
            uint32_t _size161;
            bool _sizeUnknown162;
            apache::thrift::protocol::TType _etype165;
            xfer += iprot->readSetBegin(_etype165, _size161, _sizeUnknown162);
            if (!_sizeUnknown162) {
              uint32_t _i166;
              for (_i166 = 0; _i166 < _size161; ++_i166)
              {
                int32_t _elem167;
                xfer += iprot->readI32(_elem167);
                this->k.insert(_elem167);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem168;
                xfer += iprot->readI32(_elem168);
                this->k.insert(_elem168);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k1.clear();
            uint32_t _size169;
            bool _sizeUnknown170;
            apache::thrift::protocol::TType _etype173;
            xfer += iprot->readSetBegin(_etype173, _size169, _sizeUnknown170);
            if (!_sizeUnknown170) {
              uint32_t _i174;
              for (_i174 = 0; _i174 < _size169; ++_i174)
              {
                int32_t _elem175;
                xfer += iprot->readI32(_elem175);
                this->k1.insert(_elem175);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem176;
                xfer += iprot->readI32(_elem176);
                this->k1.insert(_elem176);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k2.clear();
            uint32_t _size177;
            bool _sizeUnknown178;
            apache::thrift::protocol::TType _etype181;
            xfer += iprot->readSetBegin(_etype181, _size177, _sizeUnknown178);
            if (!_sizeUnknown178) {
              uint32_t _i182;
              for (_i182 = 0; _i182 < _size177; ++_i182)
              {
                enum2 _elem183;
                int32_t ecast184;
                xfer += iprot->readI32(ecast184);
                _elem183 = (enum2)ecast184;
                this->k2.insert(_elem183);
              }
            } else {
              while (iprot->peekSet())
              {
                enum2 _elem185;
                int32_t ecast186;
                xfer += iprot->readI32(ecast186);
                _elem185 = (enum2)ecast186;
                this->k2.insert(_elem185);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->k3.clear();
            uint32_t _size187;
            bool _sizeUnknown188;
            apache::thrift::protocol::TType _etype191;
            xfer += iprot->readSetBegin(_etype191, _size187, _sizeUnknown188);
            if (!_sizeUnknown188) {
              uint32_t _i192;
              for (_i192 = 0; _i192 < _size187; ++_i192)
              {
                structB _elem193;
                xfer += _elem193.read(iprot);
                this->k3.insert(_elem193);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem194;
                xfer += _elem194.read(iprot);
                this->k3.insert(_elem194);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.k3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l.clear();
            uint32_t _size195;
            bool _sizeUnknown196;
            apache::thrift::protocol::TType _ktype197;
            apache::thrift::protocol::TType _vtype198;
            xfer += iprot->readMapBegin(_ktype197, _vtype198, _size195, _sizeUnknown196);
            if (!_sizeUnknown196) {
              uint32_t _i200;
              for (_i200 = 0; _i200 < _size195; ++_i200)
              {
                int32_t _key201;
                xfer += iprot->readI32(_key201);
                int32_t& _val202 = this->l[_key201];
                xfer += iprot->readI32(_val202);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key203;
                xfer += iprot->readI32(_key203);
                int32_t& _val204 = this->l[_key203];
                xfer += iprot->readI32(_val204);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l1.clear();
            uint32_t _size205;
            bool _sizeUnknown206;
            apache::thrift::protocol::TType _ktype207;
            apache::thrift::protocol::TType _vtype208;
            xfer += iprot->readMapBegin(_ktype207, _vtype208, _size205, _sizeUnknown206);
            if (!_sizeUnknown206) {
              uint32_t _i210;
              for (_i210 = 0; _i210 < _size205; ++_i210)
              {
                int32_t _key211;
                xfer += iprot->readI32(_key211);
                int32_t& _val212 = this->l1[_key211];
                xfer += iprot->readI32(_val212);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key213;
                xfer += iprot->readI32(_key213);
                int32_t& _val214 = this->l1[_key213];
                xfer += iprot->readI32(_val214);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l2.clear();
            uint32_t _size215;
            bool _sizeUnknown216;
            apache::thrift::protocol::TType _ktype217;
            apache::thrift::protocol::TType _vtype218;
            xfer += iprot->readMapBegin(_ktype217, _vtype218, _size215, _sizeUnknown216);
            if (!_sizeUnknown216) {
              uint32_t _i220;
              for (_i220 = 0; _i220 < _size215; ++_i220)
              {
                int32_t _key221;
                xfer += iprot->readI32(_key221);
                enum1& _val222 = this->l2[_key221];
                int32_t ecast223;
                xfer += iprot->readI32(ecast223);
                _val222 = (enum1)ecast223;
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key224;
                xfer += iprot->readI32(_key224);
                enum1& _val225 = this->l2[_key224];
                int32_t ecast226;
                xfer += iprot->readI32(ecast226);
                _val225 = (enum1)ecast226;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->l3.clear();
            uint32_t _size227;
            bool _sizeUnknown228;
            apache::thrift::protocol::TType _ktype229;
            apache::thrift::protocol::TType _vtype230;
            xfer += iprot->readMapBegin(_ktype229, _vtype230, _size227, _sizeUnknown228);
            if (!_sizeUnknown228) {
              uint32_t _i232;
              for (_i232 = 0; _i232 < _size227; ++_i232)
              {
                int32_t _key233;
                xfer += iprot->readI32(_key233);
                structB& _val234 = this->l3[_key233];
                xfer += _val234.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                int32_t _key235;
                xfer += iprot->readI32(_key235);
                structB& _val236 = this->l3[_key235];
                xfer += _val236.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.l3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m1.clear();
            uint32_t _size237;
            bool _sizeUnknown238;
            apache::thrift::protocol::TType _ktype239;
            apache::thrift::protocol::TType _vtype240;
            xfer += iprot->readMapBegin(_ktype239, _vtype240, _size237, _sizeUnknown238);
            if (!_sizeUnknown238) {
              uint32_t _i242;
              for (_i242 = 0; _i242 < _size237; ++_i242)
              {
                enum1 _key243;
                int32_t ecast245;
                xfer += iprot->readI32(ecast245);
                _key243 = (enum1)ecast245;
                int32_t& _val244 = this->m1[_key243];
                xfer += iprot->readI32(_val244);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key246;
                int32_t ecast248;
                xfer += iprot->readI32(ecast248);
                _key246 = (enum1)ecast248;
                int32_t& _val247 = this->m1[_key246];
                xfer += iprot->readI32(_val247);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m2.clear();
            uint32_t _size249;
            bool _sizeUnknown250;
            apache::thrift::protocol::TType _ktype251;
            apache::thrift::protocol::TType _vtype252;
            xfer += iprot->readMapBegin(_ktype251, _vtype252, _size249, _sizeUnknown250);
            if (!_sizeUnknown250) {
              uint32_t _i254;
              for (_i254 = 0; _i254 < _size249; ++_i254)
              {
                enum1 _key255;
                int32_t ecast257;
                xfer += iprot->readI32(ecast257);
                _key255 = (enum1)ecast257;
                enum2& _val256 = this->m2[_key255];
                int32_t ecast258;
                xfer += iprot->readI32(ecast258);
                _val256 = (enum2)ecast258;
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key259;
                int32_t ecast261;
                xfer += iprot->readI32(ecast261);
                _key259 = (enum1)ecast261;
                enum2& _val260 = this->m2[_key259];
                int32_t ecast262;
                xfer += iprot->readI32(ecast262);
                _val260 = (enum2)ecast262;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->m3.clear();
            uint32_t _size263;
            bool _sizeUnknown264;
            apache::thrift::protocol::TType _ktype265;
            apache::thrift::protocol::TType _vtype266;
            xfer += iprot->readMapBegin(_ktype265, _vtype266, _size263, _sizeUnknown264);
            if (!_sizeUnknown264) {
              uint32_t _i268;
              for (_i268 = 0; _i268 < _size263; ++_i268)
              {
                enum1 _key269;
                int32_t ecast271;
                xfer += iprot->readI32(ecast271);
                _key269 = (enum1)ecast271;
                structB& _val270 = this->m3[_key269];
                xfer += _val270.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                enum1 _key272;
                int32_t ecast274;
                xfer += iprot->readI32(ecast274);
                _key272 = (enum1)ecast274;
                structB& _val273 = this->m3[_key272];
                xfer += _val273.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.m3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n1.clear();
            uint32_t _size275;
            bool _sizeUnknown276;
            apache::thrift::protocol::TType _ktype277;
            apache::thrift::protocol::TType _vtype278;
            xfer += iprot->readMapBegin(_ktype277, _vtype278, _size275, _sizeUnknown276);
            if (!_sizeUnknown276) {
              uint32_t _i280;
              for (_i280 = 0; _i280 < _size275; ++_i280)
              {
                std::string _key281;
                xfer += iprot->readString(_key281);
                int32_t& _val282 = this->n1[_key281];
                xfer += iprot->readI32(_val282);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key283;
                xfer += iprot->readString(_key283);
                int32_t& _val284 = this->n1[_key283];
                xfer += iprot->readI32(_val284);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n2.clear();
            uint32_t _size285;
            bool _sizeUnknown286;
            apache::thrift::protocol::TType _ktype287;
            apache::thrift::protocol::TType _vtype288;
            xfer += iprot->readMapBegin(_ktype287, _vtype288, _size285, _sizeUnknown286);
            if (!_sizeUnknown286) {
              uint32_t _i290;
              for (_i290 = 0; _i290 < _size285; ++_i290)
              {
                std::string _key291;
                xfer += iprot->readString(_key291);
                enum1& _val292 = this->n2[_key291];
                int32_t ecast293;
                xfer += iprot->readI32(ecast293);
                _val292 = (enum1)ecast293;
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key294;
                xfer += iprot->readString(_key294);
                enum1& _val295 = this->n2[_key294];
                int32_t ecast296;
                xfer += iprot->readI32(ecast296);
                _val295 = (enum1)ecast296;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->n3.clear();
            uint32_t _size297;
            bool _sizeUnknown298;
            apache::thrift::protocol::TType _ktype299;
            apache::thrift::protocol::TType _vtype300;
            xfer += iprot->readMapBegin(_ktype299, _vtype300, _size297, _sizeUnknown298);
            if (!_sizeUnknown298) {
              uint32_t _i302;
              for (_i302 = 0; _i302 < _size297; ++_i302)
              {
                std::string _key303;
                xfer += iprot->readString(_key303);
                structB& _val304 = this->n3[_key303];
                xfer += _val304.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key305;
                xfer += iprot->readString(_key305);
                structB& _val306 = this->n3[_key305];
                xfer += _val306.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.n3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o1.clear();
            uint32_t _size307;
            bool _sizeUnknown308;
            apache::thrift::protocol::TType _ktype309;
            apache::thrift::protocol::TType _vtype310;
            xfer += iprot->readMapBegin(_ktype309, _vtype310, _size307, _sizeUnknown308);
            if (!_sizeUnknown308) {
              uint32_t _i312;
              for (_i312 = 0; _i312 < _size307; ++_i312)
              {
                structA _key313;
                xfer += _key313.read(iprot);
                int32_t& _val314 = this->o1[_key313];
                xfer += iprot->readI32(_val314);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key315;
                xfer += _key315.read(iprot);
                int32_t& _val316 = this->o1[_key315];
                xfer += iprot->readI32(_val316);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 29:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o2.clear();
            uint32_t _size317;
            bool _sizeUnknown318;
            apache::thrift::protocol::TType _ktype319;
            apache::thrift::protocol::TType _vtype320;
            xfer += iprot->readMapBegin(_ktype319, _vtype320, _size317, _sizeUnknown318);
            if (!_sizeUnknown318) {
              uint32_t _i322;
              for (_i322 = 0; _i322 < _size317; ++_i322)
              {
                structA _key323;
                xfer += _key323.read(iprot);
                enum1& _val324 = this->o2[_key323];
                int32_t ecast325;
                xfer += iprot->readI32(ecast325);
                _val324 = (enum1)ecast325;
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key326;
                xfer += _key326.read(iprot);
                enum1& _val327 = this->o2[_key326];
                int32_t ecast328;
                xfer += iprot->readI32(ecast328);
                _val327 = (enum1)ecast328;
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->o3.clear();
            uint32_t _size329;
            bool _sizeUnknown330;
            apache::thrift::protocol::TType _ktype331;
            apache::thrift::protocol::TType _vtype332;
            xfer += iprot->readMapBegin(_ktype331, _vtype332, _size329, _sizeUnknown330);
            if (!_sizeUnknown330) {
              uint32_t _i334;
              for (_i334 = 0; _i334 < _size329; ++_i334)
              {
                structA _key335;
                xfer += _key335.read(iprot);
                structB& _val336 = this->o3[_key335];
                xfer += _val336.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                structA _key337;
                xfer += _key337.read(iprot);
                structB& _val338 = this->o3[_key337];
                xfer += _val338.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.o3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void structC::__clear() {
  a = 0;
  b = "";
  c = 0;
  d = 0;
  e = static_cast<enum1>(0);
  f = static_cast<enum2>(0);
  g.__clear();
  h.__clear();
  i.__clear();
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}
uint32_t structC::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("structC");
  xfer += oprot->writeFieldBegin("a", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("b", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->b);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("c", apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->c);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("d", apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->d);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("e", apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->e);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("f", apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->f);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("g", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->g.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("h", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->h.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("i", apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->i.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j.size());
    std::vector<int32_t> ::const_iterator _iter339;
    for (_iter339 = this->j.begin(); _iter339 != this->j.end(); ++_iter339)
    {
      xfer += oprot->writeI32((*_iter339));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j1", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j1.size());
    std::vector<int32_t> ::const_iterator _iter340;
    for (_iter340 = this->j1.begin(); _iter340 != this->j1.end(); ++_iter340)
    {
      xfer += oprot->writeI32((*_iter340));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j2", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->j2.size());
    std::vector<enum1> ::const_iterator _iter341;
    for (_iter341 = this->j2.begin(); _iter341 != this->j2.end(); ++_iter341)
    {
      xfer += oprot->writeI32((int32_t)(*_iter341));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("j3", apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->j3.size());
    std::vector<structA> ::const_iterator _iter342;
    for (_iter342 = this->j3.begin(); _iter342 != this->j3.end(); ++_iter342)
    {
      xfer += (*_iter342).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k.size());
    std::set<int32_t> ::const_iterator _iter343;
    for (_iter343 = this->k.begin(); _iter343 != this->k.end(); ++_iter343)
    {
      xfer += oprot->writeI32((*_iter343));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k1", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k1.size());
    std::set<int32_t> ::const_iterator _iter344;
    for (_iter344 = this->k1.begin(); _iter344 != this->k1.end(); ++_iter344)
    {
      xfer += oprot->writeI32((*_iter344));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k2", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->k2.size());
    std::set<enum2> ::const_iterator _iter345;
    for (_iter345 = this->k2.begin(); _iter345 != this->k2.end(); ++_iter345)
    {
      xfer += oprot->writeI32((int32_t)(*_iter345));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("k3", apache::thrift::protocol::T_SET, 17);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->k3.size());
    std::set<structB> ::const_iterator _iter346;
    for (_iter346 = this->k3.begin(); _iter346 != this->k3.end(); ++_iter346)
    {
      xfer += (*_iter346).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l.size());
    std::map<int32_t, int32_t> ::const_iterator _iter347;
    for (_iter347 = this->l.begin(); _iter347 != this->l.end(); ++_iter347)
    {
      xfer += oprot->writeI32(_iter347->first);
      xfer += oprot->writeI32(_iter347->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l1", apache::thrift::protocol::T_MAP, 19);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l1.size());
    std::map<int32_t, int32_t> ::const_iterator _iter348;
    for (_iter348 = this->l1.begin(); _iter348 != this->l1.end(); ++_iter348)
    {
      xfer += oprot->writeI32(_iter348->first);
      xfer += oprot->writeI32(_iter348->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l2", apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->l2.size());
    std::map<int32_t, enum1> ::const_iterator _iter349;
    for (_iter349 = this->l2.begin(); _iter349 != this->l2.end(); ++_iter349)
    {
      xfer += oprot->writeI32(_iter349->first);
      xfer += oprot->writeI32((int32_t)_iter349->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("l3", apache::thrift::protocol::T_MAP, 21);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->l3.size());
    std::map<int32_t, structB> ::const_iterator _iter350;
    for (_iter350 = this->l3.begin(); _iter350 != this->l3.end(); ++_iter350)
    {
      xfer += oprot->writeI32(_iter350->first);
      xfer += _iter350->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m1", apache::thrift::protocol::T_MAP, 22);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m1.size());
    std::map<enum1, int32_t> ::const_iterator _iter351;
    for (_iter351 = this->m1.begin(); _iter351 != this->m1.end(); ++_iter351)
    {
      xfer += oprot->writeI32((int32_t)_iter351->first);
      xfer += oprot->writeI32(_iter351->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m2", apache::thrift::protocol::T_MAP, 23);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_I32, this->m2.size());
    std::map<enum1, enum2> ::const_iterator _iter352;
    for (_iter352 = this->m2.begin(); _iter352 != this->m2.end(); ++_iter352)
    {
      xfer += oprot->writeI32((int32_t)_iter352->first);
      xfer += oprot->writeI32((int32_t)_iter352->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("m3", apache::thrift::protocol::T_MAP, 24);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_I32, apache::thrift::protocol::T_STRUCT, this->m3.size());
    std::map<enum1, structB> ::const_iterator _iter353;
    for (_iter353 = this->m3.begin(); _iter353 != this->m3.end(); ++_iter353)
    {
      xfer += oprot->writeI32((int32_t)_iter353->first);
      xfer += _iter353->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n1", apache::thrift::protocol::T_MAP, 25);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n1.size());
    std::map<std::string, int32_t> ::const_iterator _iter354;
    for (_iter354 = this->n1.begin(); _iter354 != this->n1.end(); ++_iter354)
    {
      xfer += oprot->writeString(_iter354->first);
      xfer += oprot->writeI32(_iter354->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n2", apache::thrift::protocol::T_MAP, 26);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_I32, this->n2.size());
    std::map<std::string, enum1> ::const_iterator _iter355;
    for (_iter355 = this->n2.begin(); _iter355 != this->n2.end(); ++_iter355)
    {
      xfer += oprot->writeString(_iter355->first);
      xfer += oprot->writeI32((int32_t)_iter355->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("n3", apache::thrift::protocol::T_MAP, 27);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->n3.size());
    std::map<std::string, structB> ::const_iterator _iter356;
    for (_iter356 = this->n3.begin(); _iter356 != this->n3.end(); ++_iter356)
    {
      xfer += oprot->writeString(_iter356->first);
      xfer += _iter356->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o1", apache::thrift::protocol::T_MAP, 28);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o1.size());
    std::map<structA, int32_t> ::const_iterator _iter357;
    for (_iter357 = this->o1.begin(); _iter357 != this->o1.end(); ++_iter357)
    {
      xfer += _iter357->first.write(oprot);
      xfer += oprot->writeI32(_iter357->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o2", apache::thrift::protocol::T_MAP, 29);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_I32, this->o2.size());
    std::map<structA, enum1> ::const_iterator _iter358;
    for (_iter358 = this->o2.begin(); _iter358 != this->o2.end(); ++_iter358)
    {
      xfer += _iter358->first.write(oprot);
      xfer += oprot->writeI32((int32_t)_iter358->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("o3", apache::thrift::protocol::T_MAP, 30);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRUCT, apache::thrift::protocol::T_STRUCT, this->o3.size());
    std::map<structA, structB> ::const_iterator _iter359;
    for (_iter359 = this->o3.begin(); _iter359 != this->o3.end(); ++_iter359)
    {
      xfer += _iter359->first.write(oprot);
      xfer += _iter359->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(structC &a, structC &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

void merge(const structC& from, structC& to) {
  using apache::thrift::merge;
  if (from.__isset.a) {
    merge(from.a, to.a);
    to.__isset.a = true;
  }
  if (from.__isset.b) {
    merge(from.b, to.b);
    to.__isset.b = true;
  }
  if (from.__isset.c) {
    merge(from.c, to.c);
    to.__isset.c = true;
  }
  if (from.__isset.d) {
    merge(from.d, to.d);
    to.__isset.d = true;
  }
  if (from.__isset.e) {
    merge(from.e, to.e);
    to.__isset.e = true;
  }
  if (from.__isset.f) {
    merge(from.f, to.f);
    to.__isset.f = true;
  }
  if (from.__isset.g) {
    merge(from.g, to.g);
    to.__isset.g = true;
  }
  if (from.__isset.h) {
    merge(from.h, to.h);
    to.__isset.h = true;
  }
  if (from.__isset.i) {
    merge(from.i, to.i);
    to.__isset.i = true;
  }
  if (from.__isset.j) {
    merge(from.j, to.j);
    to.__isset.j = true;
  }
  if (from.__isset.j1) {
    merge(from.j1, to.j1);
    to.__isset.j1 = true;
  }
  if (from.__isset.j2) {
    merge(from.j2, to.j2);
    to.__isset.j2 = true;
  }
  if (from.__isset.j3) {
    merge(from.j3, to.j3);
    to.__isset.j3 = true;
  }
  if (from.__isset.k) {
    merge(from.k, to.k);
    to.__isset.k = true;
  }
  if (from.__isset.k1) {
    merge(from.k1, to.k1);
    to.__isset.k1 = true;
  }
  if (from.__isset.k2) {
    merge(from.k2, to.k2);
    to.__isset.k2 = true;
  }
  if (from.__isset.k3) {
    merge(from.k3, to.k3);
    to.__isset.k3 = true;
  }
  if (from.__isset.l) {
    merge(from.l, to.l);
    to.__isset.l = true;
  }
  if (from.__isset.l1) {
    merge(from.l1, to.l1);
    to.__isset.l1 = true;
  }
  if (from.__isset.l2) {
    merge(from.l2, to.l2);
    to.__isset.l2 = true;
  }
  if (from.__isset.l3) {
    merge(from.l3, to.l3);
    to.__isset.l3 = true;
  }
  if (from.__isset.m1) {
    merge(from.m1, to.m1);
    to.__isset.m1 = true;
  }
  if (from.__isset.m2) {
    merge(from.m2, to.m2);
    to.__isset.m2 = true;
  }
  if (from.__isset.m3) {
    merge(from.m3, to.m3);
    to.__isset.m3 = true;
  }
  if (from.__isset.n1) {
    merge(from.n1, to.n1);
    to.__isset.n1 = true;
  }
  if (from.__isset.n2) {
    merge(from.n2, to.n2);
    to.__isset.n2 = true;
  }
  if (from.__isset.n3) {
    merge(from.n3, to.n3);
    to.__isset.n3 = true;
  }
  if (from.__isset.o1) {
    merge(from.o1, to.o1);
    to.__isset.o1 = true;
  }
  if (from.__isset.o2) {
    merge(from.o2, to.o2);
    to.__isset.o2 = true;
  }
  if (from.__isset.o3) {
    merge(from.o3, to.o3);
    to.__isset.o3 = true;
  }
}

void merge(structC&& from, structC& to) {
  using apache::thrift::merge;
  if (from.__isset.a) {
    merge(std::move(from.a), to.a);
    to.__isset.a = true;
  }
  if (from.__isset.b) {
    merge(std::move(from.b), to.b);
    to.__isset.b = true;
  }
  if (from.__isset.c) {
    merge(std::move(from.c), to.c);
    to.__isset.c = true;
  }
  if (from.__isset.d) {
    merge(std::move(from.d), to.d);
    to.__isset.d = true;
  }
  if (from.__isset.e) {
    merge(std::move(from.e), to.e);
    to.__isset.e = true;
  }
  if (from.__isset.f) {
    merge(std::move(from.f), to.f);
    to.__isset.f = true;
  }
  if (from.__isset.g) {
    merge(std::move(from.g), to.g);
    to.__isset.g = true;
  }
  if (from.__isset.h) {
    merge(std::move(from.h), to.h);
    to.__isset.h = true;
  }
  if (from.__isset.i) {
    merge(std::move(from.i), to.i);
    to.__isset.i = true;
  }
  if (from.__isset.j) {
    merge(std::move(from.j), to.j);
    to.__isset.j = true;
  }
  if (from.__isset.j1) {
    merge(std::move(from.j1), to.j1);
    to.__isset.j1 = true;
  }
  if (from.__isset.j2) {
    merge(std::move(from.j2), to.j2);
    to.__isset.j2 = true;
  }
  if (from.__isset.j3) {
    merge(std::move(from.j3), to.j3);
    to.__isset.j3 = true;
  }
  if (from.__isset.k) {
    merge(std::move(from.k), to.k);
    to.__isset.k = true;
  }
  if (from.__isset.k1) {
    merge(std::move(from.k1), to.k1);
    to.__isset.k1 = true;
  }
  if (from.__isset.k2) {
    merge(std::move(from.k2), to.k2);
    to.__isset.k2 = true;
  }
  if (from.__isset.k3) {
    merge(std::move(from.k3), to.k3);
    to.__isset.k3 = true;
  }
  if (from.__isset.l) {
    merge(std::move(from.l), to.l);
    to.__isset.l = true;
  }
  if (from.__isset.l1) {
    merge(std::move(from.l1), to.l1);
    to.__isset.l1 = true;
  }
  if (from.__isset.l2) {
    merge(std::move(from.l2), to.l2);
    to.__isset.l2 = true;
  }
  if (from.__isset.l3) {
    merge(std::move(from.l3), to.l3);
    to.__isset.l3 = true;
  }
  if (from.__isset.m1) {
    merge(std::move(from.m1), to.m1);
    to.__isset.m1 = true;
  }
  if (from.__isset.m2) {
    merge(std::move(from.m2), to.m2);
    to.__isset.m2 = true;
  }
  if (from.__isset.m3) {
    merge(std::move(from.m3), to.m3);
    to.__isset.m3 = true;
  }
  if (from.__isset.n1) {
    merge(std::move(from.n1), to.n1);
    to.__isset.n1 = true;
  }
  if (from.__isset.n2) {
    merge(std::move(from.n2), to.n2);
    to.__isset.n2 = true;
  }
  if (from.__isset.n3) {
    merge(std::move(from.n3), to.n3);
    to.__isset.n3 = true;
  }
  if (from.__isset.o1) {
    merge(std::move(from.o1), to.o1);
    to.__isset.o1 = true;
  }
  if (from.__isset.o2) {
    merge(std::move(from.o2), to.o2);
    to.__isset.o2 = true;
  }
  if (from.__isset.o3) {
    merge(std::move(from.o3), to.o3);
    to.__isset.o3 = true;
  }
}

const uint64_t struct1::_reflection_id;
void struct1::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(schema);
}

bool struct1::operator == (const struct1 & rhs) const {
  if (!(this->field0 == rhs.field0))
    return false;
  if (__isset.field1 != rhs.__isset.field1)
    return false;
  else if (__isset.field1 && !(field1 == rhs.field1))
    return false;
  if (!(this->field2 == rhs.field2))
    return false;
  if (!(this->field3 == rhs.field3))
    return false;
  if (__isset.field4 != rhs.__isset.field4)
    return false;
  else if (__isset.field4 && !(field4 == rhs.field4))
    return false;
  if (!(this->field5 == rhs.field5))
    return false;
  return true;
}

void struct1::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["field0"] != nullptr) {
    int64_t _tmp361 = (int64_t)parsed["field0"].asInt();
    if (imaxabs(_tmp361) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->field0 = (int32_t)_tmp361;
    }
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field1"] != nullptr) {
    this->field1 = parsed["field1"].asString().toStdString();
    this->__isset.field1 = true;
  } else {
    this->__isset.field1 = false;
  }
  if (parsed["field2"] != nullptr) {
    this->field2=(enum1)(int32_t)parsed["field2"].asInt();
    this->__isset.field2 = true;
  } else {
    this->__isset.field2 = false;
  }
  if (parsed["field3"] != nullptr) {
    this->field3=(enum2)(int32_t)parsed["field3"].asInt();
  } else {
    throw apache::thrift::TLibraryException("can't parse a required field!");
  }
  if (parsed["field4"] != nullptr) {
    this->field4.readFromJson(folly::toJson(parsed["field4"]).toStdString().c_str());
    this->__isset.field4 = true;
  } else {
    this->__isset.field4 = false;
  }
  if (parsed["field5"] != nullptr) {
    this->field5.readFromJson(folly::toJson(parsed["field5"]).toStdString().c_str());
    this->__isset.field5 = true;
  } else {
    this->__isset.field5 = false;
  }
}
void struct1::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct1::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_18317194148543753228(*schema);
    iprot->setNextStructType(struct1::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;


  bool isset_field0 = false;
  bool isset_field3 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field0);
          isset_field0 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field1);
          this->__isset.field1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast364;
          xfer += iprot->readI32(ecast364);
          this->field2 = (enum1)ecast364;
          this->__isset.field2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast365;
          xfer += iprot->readI32(ecast365);
          this->field3 = (enum2)ecast365;
          isset_field3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field4.read(iprot);
          this->__isset.field4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->field5.read(iprot);
          this->__isset.field5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_field0)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field0' was not found in serialized data! Struct: struct1");
  if (!isset_field3)
    throw TProtocolException(TProtocolException::MISSING_REQUIRED_FIELD, "Required field 'field3' was not found in serialized data! Struct: struct1");
  return xfer;
}

void struct1::__clear() {
  field0 = 0;
  field1 = "";
  field2 = static_cast<enum1>(0);
  field3 = static_cast<enum2>(0);
  field4.__clear();
  field5.__clear();
  __isset.__clear();
}
uint32_t struct1::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct1");
  xfer += oprot->writeFieldBegin("field0", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field0);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field1) {
    xfer += oprot->writeFieldBegin("field1", apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->field1);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field2", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->field2);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("field3", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->field3);
  xfer += oprot->writeFieldEnd();
  if (this->__isset.field4) {
    xfer += oprot->writeFieldBegin("field4", apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->field4.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("field5", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->field5.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct1 &a, struct1 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

void merge(const struct1& from, struct1& to) {
  using apache::thrift::merge;
  merge(from.field0, to.field0);
  if (from.__isset.field1) {
    merge(from.field1, to.field1);
    to.__isset.field1 = true;
  }
  if (from.__isset.field2) {
    merge(from.field2, to.field2);
    to.__isset.field2 = true;
  }
  merge(from.field3, to.field3);
  if (from.__isset.field4) {
    merge(from.field4, to.field4);
    to.__isset.field4 = true;
  }
  if (from.__isset.field5) {
    merge(from.field5, to.field5);
    to.__isset.field5 = true;
  }
}

void merge(struct1&& from, struct1& to) {
  using apache::thrift::merge;
  merge(std::move(from.field0), to.field0);
  if (from.__isset.field1) {
    merge(std::move(from.field1), to.field1);
    to.__isset.field1 = true;
  }
  if (from.__isset.field2) {
    merge(std::move(from.field2), to.field2);
    to.__isset.field2 = true;
  }
  merge(std::move(from.field3), to.field3);
  if (from.__isset.field4) {
    merge(std::move(from.field4), to.field4);
    to.__isset.field4 = true;
  }
  if (from.__isset.field5) {
    merge(std::move(from.field5), to.field5);
    to.__isset.field5 = true;
  }
}

const uint64_t struct2::_reflection_id;
void struct2::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(schema);
}

bool struct2::operator == (const struct2 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  return true;
}

void struct2::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp367 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp367) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp367;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString().toStdString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).toStdString().c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).toStdString().c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).toStdString().c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
}
void struct2::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct2::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_13919930284671800588(*schema);
    iprot->setNextStructType(struct2::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast370;
          xfer += iprot->readI32(ecast370);
          this->fieldC = (enum1)ecast370;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast371;
          xfer += iprot->readI32(ecast371);
          this->fieldD = (enum2)ecast371;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct2::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  __isset.__clear();
}
uint32_t struct2::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct2");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct2 &a, struct2 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

void merge(const struct2& from, struct2& to) {
  using apache::thrift::merge;
  if (from.__isset.fieldA) {
    merge(from.fieldA, to.fieldA);
    to.__isset.fieldA = true;
  }
  if (from.__isset.fieldB) {
    merge(from.fieldB, to.fieldB);
    to.__isset.fieldB = true;
  }
  if (from.__isset.fieldC) {
    merge(from.fieldC, to.fieldC);
    to.__isset.fieldC = true;
  }
  if (from.__isset.fieldD) {
    merge(from.fieldD, to.fieldD);
    to.__isset.fieldD = true;
  }
  if (from.__isset.fieldE) {
    merge(from.fieldE, to.fieldE);
    to.__isset.fieldE = true;
  }
  if (from.__isset.fieldF) {
    merge(from.fieldF, to.fieldF);
    to.__isset.fieldF = true;
  }
  if (from.__isset.fieldG) {
    merge(from.fieldG, to.fieldG);
    to.__isset.fieldG = true;
  }
}

void merge(struct2&& from, struct2& to) {
  using apache::thrift::merge;
  if (from.__isset.fieldA) {
    merge(std::move(from.fieldA), to.fieldA);
    to.__isset.fieldA = true;
  }
  if (from.__isset.fieldB) {
    merge(std::move(from.fieldB), to.fieldB);
    to.__isset.fieldB = true;
  }
  if (from.__isset.fieldC) {
    merge(std::move(from.fieldC), to.fieldC);
    to.__isset.fieldC = true;
  }
  if (from.__isset.fieldD) {
    merge(std::move(from.fieldD), to.fieldD);
    to.__isset.fieldD = true;
  }
  if (from.__isset.fieldE) {
    merge(std::move(from.fieldE), to.fieldE);
    to.__isset.fieldE = true;
  }
  if (from.__isset.fieldF) {
    merge(std::move(from.fieldF), to.fieldF);
    to.__isset.fieldF = true;
  }
  if (from.__isset.fieldG) {
    merge(std::move(from.fieldG), to.fieldG);
    to.__isset.fieldG = true;
  }
}

const uint64_t struct3::_reflection_id;
void struct3::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(schema);
}

bool struct3::operator == (const struct3 & rhs) const {
  if (!(this->fieldA == rhs.fieldA))
    return false;
  if (!(this->fieldB == rhs.fieldB))
    return false;
  if (!(this->fieldC == rhs.fieldC))
    return false;
  if (!(this->fieldD == rhs.fieldD))
    return false;
  if (!(this->fieldE == rhs.fieldE))
    return false;
  if (!(this->fieldF == rhs.fieldF))
    return false;
  if (!(this->fieldG == rhs.fieldG))
    return false;
  if (!(this->fieldH == rhs.fieldH))
    return false;
  if (!(this->fieldI == rhs.fieldI))
    return false;
  if (!(this->fieldJ == rhs.fieldJ))
    return false;
  if (!(this->fieldK == rhs.fieldK))
    return false;
  if (!(this->fieldL == rhs.fieldL))
    return false;
  if (!(this->fieldM == rhs.fieldM))
    return false;
  if (!(this->fieldN == rhs.fieldN))
    return false;
  if (!(this->fieldO == rhs.fieldO))
    return false;
  if (!(this->fieldP == rhs.fieldP))
    return false;
  if (!(this->fieldQ == rhs.fieldQ))
    return false;
  if (!(this->fieldR == rhs.fieldR))
    return false;
  return true;
}

void struct3::readFromJson(const char* jsonText, size_t len)
{
  folly::dynamic parsed = folly::parseJson(folly::StringPiece(jsonText, len));
  if (parsed["fieldA"] != nullptr) {
    int64_t _tmp373 = (int64_t)parsed["fieldA"].asInt();
    if (imaxabs(_tmp373) > 0x7fffffffL) {
      throw apache::thrift::TLibraryException("number exceeds limit in field");
    } else {
      this->fieldA = (int32_t)_tmp373;
    }
    this->__isset.fieldA = true;
  } else {
    this->__isset.fieldA = false;
  }
  if (parsed["fieldB"] != nullptr) {
    this->fieldB = parsed["fieldB"].asString().toStdString();
    this->__isset.fieldB = true;
  } else {
    this->__isset.fieldB = false;
  }
  if (parsed["fieldC"] != nullptr) {
    this->fieldC=(enum1)(int32_t)parsed["fieldC"].asInt();
    this->__isset.fieldC = true;
  } else {
    this->__isset.fieldC = false;
  }
  if (parsed["fieldD"] != nullptr) {
    this->fieldD=(enum2)(int32_t)parsed["fieldD"].asInt();
    this->__isset.fieldD = true;
  } else {
    this->__isset.fieldD = false;
  }
  if (parsed["fieldE"] != nullptr) {
    this->fieldE.readFromJson(folly::toJson(parsed["fieldE"]).toStdString().c_str());
    this->__isset.fieldE = true;
  } else {
    this->__isset.fieldE = false;
  }
  if (parsed["fieldF"] != nullptr) {
    this->fieldF.readFromJson(folly::toJson(parsed["fieldF"]).toStdString().c_str());
    this->__isset.fieldF = true;
  } else {
    this->__isset.fieldF = false;
  }
  if (parsed["fieldG"] != nullptr) {
    this->fieldG.readFromJson(folly::toJson(parsed["fieldG"]).toStdString().c_str());
    this->__isset.fieldG = true;
  } else {
    this->__isset.fieldG = false;
  }
  if (parsed["fieldH"] != nullptr) {
    this->fieldH.readFromJson(folly::toJson(parsed["fieldH"]).toStdString().c_str());
    this->__isset.fieldH = true;
  } else {
    this->__isset.fieldH = false;
  }
  if (parsed["fieldI"] != nullptr) {
    folly::dynamic _json378 = parsed["fieldI"];
    this->fieldI.clear();
    uint32_t _size376 = _json378.size();
    this->fieldI.resize(_size376);
    for (uint32_t _i377 = 0; _i377 < _size376; ++_i377)
    {
      int64_t _tmp379 = (int64_t)_json378[_i377].asInt();
      if (imaxabs(_tmp379) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        this->fieldI[_i377] = (int32_t)_tmp379;
      }
    }
    this->__isset.fieldI = true;
  } else {
    this->__isset.fieldI = false;
  }
  if (parsed["fieldJ"] != nullptr) {
    folly::dynamic _json382 = parsed["fieldJ"];
    this->fieldJ.clear();
    uint32_t _size380 = _json382.size();
    this->fieldJ.resize(_size380);
    for (uint32_t _i381 = 0; _i381 < _size380; ++_i381)
    {
      this->fieldJ[_i381] = _json382[_i381].asString().toStdString();
    }
    this->__isset.fieldJ = true;
  } else {
    this->__isset.fieldJ = false;
  }
  if (parsed["fieldK"] != nullptr) {
    folly::dynamic _json385 = parsed["fieldK"];
    this->fieldK.clear();
    uint32_t _size383 = _json385.size();
    this->fieldK.resize(_size383);
    for (uint32_t _i384 = 0; _i384 < _size383; ++_i384)
    {
      this->fieldK[_i384] = _json385[_i384].asString().toStdString();
    }
    this->__isset.fieldK = true;
  } else {
    this->__isset.fieldK = false;
  }
  if (parsed["fieldL"] != nullptr) {
    folly::dynamic _json388 = parsed["fieldL"];
    this->fieldL.clear();
    uint32_t _size386 = _json388.size();
    this->fieldL.resize(_size386);
    for (uint32_t _i387 = 0; _i387 < _size386; ++_i387)
    {
      this->fieldL[_i387].readFromJson(folly::toJson(_json388[_i387]).toStdString().c_str());
    }
    this->__isset.fieldL = true;
  } else {
    this->__isset.fieldL = false;
  }
  if (parsed["fieldM"] != nullptr) {
    folly::dynamic _json391 = parsed["fieldM"];
    this->fieldM.clear();
    uint32_t _size389 = _json391.size();
    for (uint32_t _i390 = 0; _i390 < _size389; ++_i390)
    {
      int32_t _elem392;
      int64_t _tmp393 = (int64_t)_json391[_i390].asInt();
      if (imaxabs(_tmp393) > 0x7fffffffL) {
        throw apache::thrift::TLibraryException("number exceeds limit in field");
      } else {
        _elem392 = (int32_t)_tmp393;
      }
      this->fieldM.insert(_elem392);
    }
    this->__isset.fieldM = true;
  } else {
    this->__isset.fieldM = false;
  }
  if (parsed["fieldN"] != nullptr) {
    folly::dynamic _json396 = parsed["fieldN"];
    this->fieldN.clear();
    uint32_t _size394 = _json396.size();
    for (uint32_t _i395 = 0; _i395 < _size394; ++_i395)
    {
      std::string _elem397;
      _elem397 = _json396[_i395].asString().toStdString();
      this->fieldN.insert(_elem397);
    }
    this->__isset.fieldN = true;
  } else {
    this->__isset.fieldN = false;
  }
  if (parsed["fieldO"] != nullptr) {
    folly::dynamic _json400 = parsed["fieldO"];
    this->fieldO.clear();
    uint32_t _size398 = _json400.size();
    for (uint32_t _i399 = 0; _i399 < _size398; ++_i399)
    {
      std::string _elem401;
      _elem401 = _json400[_i399].asString().toStdString();
      this->fieldO.insert(_elem401);
    }
    this->__isset.fieldO = true;
  } else {
    this->__isset.fieldO = false;
  }
  if (parsed["fieldP"] != nullptr) {
    folly::dynamic _json404 = parsed["fieldP"];
    this->fieldP.clear();
    uint32_t _size402 = _json404.size();
    for (uint32_t _i403 = 0; _i403 < _size402; ++_i403)
    {
      structB _elem405;
      _elem405.readFromJson(folly::toJson(_json404[_i403]).toStdString().c_str());
      this->fieldP.insert(_elem405);
    }
    this->__isset.fieldP = true;
  } else {
    this->__isset.fieldP = false;
  }
  if (parsed["fieldQ"] != nullptr) {
    folly::dynamic _json408 = parsed["fieldQ"];
    this->fieldQ.clear();
    for (folly::dynamic::const_item_iterator _iter409 = _json408.items().begin(); _iter409 != _json408.items().end(); _iter409++)    {
      std::string _key410;;
      structA _val411;;
      _key410 = (_iter409)->first.asString().toStdString();
      _val411.readFromJson(folly::toJson(_iter409->second).toStdString().c_str());
      this->fieldQ[_key410] = _val411;
    }
    this->__isset.fieldQ = true;
  } else {
    this->__isset.fieldQ = false;
  }
  if (parsed["fieldR"] != nullptr) {
    folly::dynamic _json414 = parsed["fieldR"];
    this->fieldR.clear();
    for (folly::dynamic::const_item_iterator _iter415 = _json414.items().begin(); _iter415 != _json414.items().end(); _iter415++)    {
      std::string _key416;;
      structB _val417;;
      _key416 = (_iter415)->first.asString().toStdString();
      _val417.readFromJson(folly::toJson(_iter415->second).toStdString().c_str());
      this->fieldR[_key416] = _val417;
    }
    this->__isset.fieldR = true;
  } else {
    this->__isset.fieldR = false;
  }
}
void struct3::readFromJson(const char* jsonText)
{
  readFromJson(jsonText, strlen(jsonText));
}

uint32_t struct3::read(apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  apache::thrift::protocol::TType ftype;
  int16_t fid;

  ::apache::thrift::reflection::Schema * schema = iprot->getSchema();
  if (schema != nullptr) {
     ::test_cpp1::cpp_reflection::module_reflection_::reflectionInitializer_16392874475279945260(*schema);
    iprot->setNextStructType(struct3::_reflection_id);
  }
  xfer += iprot->readStructBegin(fname);

  using apache::thrift::protocol::TProtocolException;

  std::exception_ptr exception;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fieldA);
          this->__isset.fieldA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fieldB);
          this->__isset.fieldB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast418;
          xfer += iprot->readI32(ecast418);
          this->fieldC = (enum1)ecast418;
          this->__isset.fieldC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == apache::thrift::protocol::T_I32) {
          int32_t ecast419;
          xfer += iprot->readI32(ecast419);
          this->fieldD = (enum2)ecast419;
          this->__isset.fieldD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldE.read(iprot);
          this->__isset.fieldE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldF.read(iprot);
          this->__isset.fieldF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          try {
            xfer += this->fieldG.read(iprot);
          } catch (const TProtocolException& e) {
            if (e.getType() != TProtocolException::MISSING_REQUIRED_FIELD) {
              throw;
            }
            exception = std::current_exception();
          }
          this->__isset.fieldG = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == apache::thrift::protocol::T_STRUCT) {
          xfer += this->fieldH.read(iprot);
          this->__isset.fieldH = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldI.clear();
            uint32_t _size420;
            bool _sizeUnknown421;
            apache::thrift::protocol::TType _etype424;
            xfer += iprot->readListBegin(_etype424, _size420, _sizeUnknown421);
            if (!_sizeUnknown421) {
              this->fieldI.resize(_size420);
              uint32_t _i425;
              for (_i425 = 0; _i425 < _size420; ++_i425)
              {
                xfer += iprot->readI32(this->fieldI[_i425]);
              }
            } else {
              while (iprot->peekList())
              {
                int32_t _elem426;
                xfer += iprot->readI32(_elem426);
                this->fieldI.push_back(_elem426);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldI = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldJ.clear();
            uint32_t _size427;
            bool _sizeUnknown428;
            apache::thrift::protocol::TType _etype431;
            xfer += iprot->readListBegin(_etype431, _size427, _sizeUnknown428);
            if (!_sizeUnknown428) {
              this->fieldJ.resize(_size427);
              uint32_t _i432;
              for (_i432 = 0; _i432 < _size427; ++_i432)
              {
                xfer += iprot->readString(this->fieldJ[_i432]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem433;
                xfer += iprot->readString(_elem433);
                this->fieldJ.push_back(_elem433);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldJ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldK.clear();
            uint32_t _size434;
            bool _sizeUnknown435;
            apache::thrift::protocol::TType _etype438;
            xfer += iprot->readListBegin(_etype438, _size434, _sizeUnknown435);
            if (!_sizeUnknown435) {
              this->fieldK.resize(_size434);
              uint32_t _i439;
              for (_i439 = 0; _i439 < _size434; ++_i439)
              {
                xfer += iprot->readString(this->fieldK[_i439]);
              }
            } else {
              while (iprot->peekList())
              {
                std::string _elem440;
                xfer += iprot->readString(_elem440);
                this->fieldK.push_back(_elem440);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == apache::thrift::protocol::T_LIST) {
          {
            this->fieldL.clear();
            uint32_t _size441;
            bool _sizeUnknown442;
            apache::thrift::protocol::TType _etype445;
            xfer += iprot->readListBegin(_etype445, _size441, _sizeUnknown442);
            if (!_sizeUnknown442) {
              this->fieldL.resize(_size441);
              uint32_t _i446;
              for (_i446 = 0; _i446 < _size441; ++_i446)
              {
                xfer += this->fieldL[_i446].read(iprot);
              }
            } else {
              while (iprot->peekList())
              {
                structA _elem447;
                xfer += _elem447.read(iprot);
                this->fieldL.push_back(_elem447);
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fieldL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldM.clear();
            uint32_t _size448;
            bool _sizeUnknown449;
            apache::thrift::protocol::TType _etype452;
            xfer += iprot->readSetBegin(_etype452, _size448, _sizeUnknown449);
            if (!_sizeUnknown449) {
              uint32_t _i453;
              for (_i453 = 0; _i453 < _size448; ++_i453)
              {
                int32_t _elem454;
                xfer += iprot->readI32(_elem454);
                this->fieldM.insert(_elem454);
              }
            } else {
              while (iprot->peekSet())
              {
                int32_t _elem455;
                xfer += iprot->readI32(_elem455);
                this->fieldM.insert(_elem455);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldM = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldN.clear();
            uint32_t _size456;
            bool _sizeUnknown457;
            apache::thrift::protocol::TType _etype460;
            xfer += iprot->readSetBegin(_etype460, _size456, _sizeUnknown457);
            if (!_sizeUnknown457) {
              uint32_t _i461;
              for (_i461 = 0; _i461 < _size456; ++_i461)
              {
                std::string _elem462;
                xfer += iprot->readString(_elem462);
                this->fieldN.insert(_elem462);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem463;
                xfer += iprot->readString(_elem463);
                this->fieldN.insert(_elem463);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldN = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldO.clear();
            uint32_t _size464;
            bool _sizeUnknown465;
            apache::thrift::protocol::TType _etype468;
            xfer += iprot->readSetBegin(_etype468, _size464, _sizeUnknown465);
            if (!_sizeUnknown465) {
              uint32_t _i469;
              for (_i469 = 0; _i469 < _size464; ++_i469)
              {
                std::string _elem470;
                xfer += iprot->readString(_elem470);
                this->fieldO.insert(_elem470);
              }
            } else {
              while (iprot->peekSet())
              {
                std::string _elem471;
                xfer += iprot->readString(_elem471);
                this->fieldO.insert(_elem471);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldO = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == apache::thrift::protocol::T_SET) {
          {
            this->fieldP.clear();
            uint32_t _size472;
            bool _sizeUnknown473;
            apache::thrift::protocol::TType _etype476;
            xfer += iprot->readSetBegin(_etype476, _size472, _sizeUnknown473);
            if (!_sizeUnknown473) {
              uint32_t _i477;
              for (_i477 = 0; _i477 < _size472; ++_i477)
              {
                structB _elem478;
                xfer += _elem478.read(iprot);
                this->fieldP.insert(_elem478);
              }
            } else {
              while (iprot->peekSet())
              {
                structB _elem479;
                xfer += _elem479.read(iprot);
                this->fieldP.insert(_elem479);
              }
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.fieldP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldQ.clear();
            uint32_t _size480;
            bool _sizeUnknown481;
            apache::thrift::protocol::TType _ktype482;
            apache::thrift::protocol::TType _vtype483;
            xfer += iprot->readMapBegin(_ktype482, _vtype483, _size480, _sizeUnknown481);
            if (!_sizeUnknown481) {
              uint32_t _i485;
              for (_i485 = 0; _i485 < _size480; ++_i485)
              {
                std::string _key486;
                xfer += iprot->readString(_key486);
                structA& _val487 = this->fieldQ[_key486];
                xfer += _val487.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key488;
                xfer += iprot->readString(_key488);
                structA& _val489 = this->fieldQ[_key488];
                xfer += _val489.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldQ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == apache::thrift::protocol::T_MAP) {
          {
            this->fieldR.clear();
            uint32_t _size490;
            bool _sizeUnknown491;
            apache::thrift::protocol::TType _ktype492;
            apache::thrift::protocol::TType _vtype493;
            xfer += iprot->readMapBegin(_ktype492, _vtype493, _size490, _sizeUnknown491);
            if (!_sizeUnknown491) {
              uint32_t _i495;
              for (_i495 = 0; _i495 < _size490; ++_i495)
              {
                std::string _key496;
                xfer += iprot->readString(_key496);
                structB& _val497 = this->fieldR[_key496];
                xfer += _val497.read(iprot);
              }
            } else {
              while (iprot->peekMap())
              {
                std::string _key498;
                xfer += iprot->readString(_key498);
                structB& _val499 = this->fieldR[_key498];
                xfer += _val499.read(iprot);
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.fieldR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (exception != std::exception_ptr()) {
    std::rethrow_exception(exception);
  }
  return xfer;
}

void struct3::__clear() {
  fieldA = 0;
  fieldB = "";
  fieldC = static_cast<enum1>(0);
  fieldD = static_cast<enum2>(0);
  fieldE.__clear();
  fieldF.__clear();
  fieldG.__clear();
  fieldH.__clear();
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}
uint32_t struct3::write(apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("struct3");
  xfer += oprot->writeFieldBegin("fieldA", apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->fieldA);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldB", apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->fieldB);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldC", apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->fieldC);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldD", apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->fieldD);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldE", apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->fieldE.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldF", apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->fieldF.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldG", apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->fieldG.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldH", apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->fieldH.write(oprot);
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldI", apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_I32, this->fieldI.size());
    std::vector<int32_t> ::const_iterator _iter500;
    for (_iter500 = this->fieldI.begin(); _iter500 != this->fieldI.end(); ++_iter500)
    {
      xfer += oprot->writeI32((*_iter500));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldJ", apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldJ.size());
    std::vector<std::string> ::const_iterator _iter501;
    for (_iter501 = this->fieldJ.begin(); _iter501 != this->fieldJ.end(); ++_iter501)
    {
      xfer += oprot->writeString((*_iter501));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldK", apache::thrift::protocol::T_LIST, 11);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRING, this->fieldK.size());
    std::vector<std::string> ::const_iterator _iter502;
    for (_iter502 = this->fieldK.begin(); _iter502 != this->fieldK.end(); ++_iter502)
    {
      xfer += oprot->writeString((*_iter502));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldL", apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(apache::thrift::protocol::T_STRUCT, this->fieldL.size());
    std::vector<structA> ::const_iterator _iter503;
    for (_iter503 = this->fieldL.begin(); _iter503 != this->fieldL.end(); ++_iter503)
    {
      xfer += (*_iter503).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldM", apache::thrift::protocol::T_SET, 13);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_I32, this->fieldM.size());
    std::set<int32_t> ::const_iterator _iter504;
    for (_iter504 = this->fieldM.begin(); _iter504 != this->fieldM.end(); ++_iter504)
    {
      xfer += oprot->writeI32((*_iter504));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldN", apache::thrift::protocol::T_SET, 14);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldN.size());
    std::set<std::string> ::const_iterator _iter505;
    for (_iter505 = this->fieldN.begin(); _iter505 != this->fieldN.end(); ++_iter505)
    {
      xfer += oprot->writeString((*_iter505));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldO", apache::thrift::protocol::T_SET, 15);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRING, this->fieldO.size());
    std::set<std::string> ::const_iterator _iter506;
    for (_iter506 = this->fieldO.begin(); _iter506 != this->fieldO.end(); ++_iter506)
    {
      xfer += oprot->writeString((*_iter506));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldP", apache::thrift::protocol::T_SET, 16);
  {
    xfer += oprot->writeSetBegin(apache::thrift::protocol::T_STRUCT, this->fieldP.size());
    std::set<structB> ::const_iterator _iter507;
    for (_iter507 = this->fieldP.begin(); _iter507 != this->fieldP.end(); ++_iter507)
    {
      xfer += (*_iter507).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldQ", apache::thrift::protocol::T_MAP, 17);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldQ.size());
    std::map<std::string, structA> ::const_iterator _iter508;
    for (_iter508 = this->fieldQ.begin(); _iter508 != this->fieldQ.end(); ++_iter508)
    {
      xfer += oprot->writeString(_iter508->first);
      xfer += _iter508->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldBegin("fieldR", apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(apache::thrift::protocol::T_STRING, apache::thrift::protocol::T_STRUCT, this->fieldR.size());
    std::map<std::string, structB> ::const_iterator _iter509;
    for (_iter509 = this->fieldR.begin(); _iter509 != this->fieldR.end(); ++_iter509)
    {
      xfer += oprot->writeString(_iter509->first);
      xfer += _iter509->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(struct3 &a, struct3 &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

void merge(const struct3& from, struct3& to) {
  using apache::thrift::merge;
  if (from.__isset.fieldA) {
    merge(from.fieldA, to.fieldA);
    to.__isset.fieldA = true;
  }
  if (from.__isset.fieldB) {
    merge(from.fieldB, to.fieldB);
    to.__isset.fieldB = true;
  }
  if (from.__isset.fieldC) {
    merge(from.fieldC, to.fieldC);
    to.__isset.fieldC = true;
  }
  if (from.__isset.fieldD) {
    merge(from.fieldD, to.fieldD);
    to.__isset.fieldD = true;
  }
  if (from.__isset.fieldE) {
    merge(from.fieldE, to.fieldE);
    to.__isset.fieldE = true;
  }
  if (from.__isset.fieldF) {
    merge(from.fieldF, to.fieldF);
    to.__isset.fieldF = true;
  }
  if (from.__isset.fieldG) {
    merge(from.fieldG, to.fieldG);
    to.__isset.fieldG = true;
  }
  if (from.__isset.fieldH) {
    merge(from.fieldH, to.fieldH);
    to.__isset.fieldH = true;
  }
  if (from.__isset.fieldI) {
    merge(from.fieldI, to.fieldI);
    to.__isset.fieldI = true;
  }
  if (from.__isset.fieldJ) {
    merge(from.fieldJ, to.fieldJ);
    to.__isset.fieldJ = true;
  }
  if (from.__isset.fieldK) {
    merge(from.fieldK, to.fieldK);
    to.__isset.fieldK = true;
  }
  if (from.__isset.fieldL) {
    merge(from.fieldL, to.fieldL);
    to.__isset.fieldL = true;
  }
  if (from.__isset.fieldM) {
    merge(from.fieldM, to.fieldM);
    to.__isset.fieldM = true;
  }
  if (from.__isset.fieldN) {
    merge(from.fieldN, to.fieldN);
    to.__isset.fieldN = true;
  }
  if (from.__isset.fieldO) {
    merge(from.fieldO, to.fieldO);
    to.__isset.fieldO = true;
  }
  if (from.__isset.fieldP) {
    merge(from.fieldP, to.fieldP);
    to.__isset.fieldP = true;
  }
  if (from.__isset.fieldQ) {
    merge(from.fieldQ, to.fieldQ);
    to.__isset.fieldQ = true;
  }
  if (from.__isset.fieldR) {
    merge(from.fieldR, to.fieldR);
    to.__isset.fieldR = true;
  }
}

void merge(struct3&& from, struct3& to) {
  using apache::thrift::merge;
  if (from.__isset.fieldA) {
    merge(std::move(from.fieldA), to.fieldA);
    to.__isset.fieldA = true;
  }
  if (from.__isset.fieldB) {
    merge(std::move(from.fieldB), to.fieldB);
    to.__isset.fieldB = true;
  }
  if (from.__isset.fieldC) {
    merge(std::move(from.fieldC), to.fieldC);
    to.__isset.fieldC = true;
  }
  if (from.__isset.fieldD) {
    merge(std::move(from.fieldD), to.fieldD);
    to.__isset.fieldD = true;
  }
  if (from.__isset.fieldE) {
    merge(std::move(from.fieldE), to.fieldE);
    to.__isset.fieldE = true;
  }
  if (from.__isset.fieldF) {
    merge(std::move(from.fieldF), to.fieldF);
    to.__isset.fieldF = true;
  }
  if (from.__isset.fieldG) {
    merge(std::move(from.fieldG), to.fieldG);
    to.__isset.fieldG = true;
  }
  if (from.__isset.fieldH) {
    merge(std::move(from.fieldH), to.fieldH);
    to.__isset.fieldH = true;
  }
  if (from.__isset.fieldI) {
    merge(std::move(from.fieldI), to.fieldI);
    to.__isset.fieldI = true;
  }
  if (from.__isset.fieldJ) {
    merge(std::move(from.fieldJ), to.fieldJ);
    to.__isset.fieldJ = true;
  }
  if (from.__isset.fieldK) {
    merge(std::move(from.fieldK), to.fieldK);
    to.__isset.fieldK = true;
  }
  if (from.__isset.fieldL) {
    merge(std::move(from.fieldL), to.fieldL);
    to.__isset.fieldL = true;
  }
  if (from.__isset.fieldM) {
    merge(std::move(from.fieldM), to.fieldM);
    to.__isset.fieldM = true;
  }
  if (from.__isset.fieldN) {
    merge(std::move(from.fieldN), to.fieldN);
    to.__isset.fieldN = true;
  }
  if (from.__isset.fieldO) {
    merge(std::move(from.fieldO), to.fieldO);
    to.__isset.fieldO = true;
  }
  if (from.__isset.fieldP) {
    merge(std::move(from.fieldP), to.fieldP);
    to.__isset.fieldP = true;
  }
  if (from.__isset.fieldQ) {
    merge(std::move(from.fieldQ), to.fieldQ);
    to.__isset.fieldQ = true;
  }
  if (from.__isset.fieldR) {
    merge(std::move(from.fieldR), to.fieldR);
    to.__isset.fieldR = true;
  }
}

}} // namespace
