/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "module_types.h"

#include "module_types.tcc"

#include <algorithm>

namespace test_cpp2 { namespace cpp_reflection {

enum1 _kenum1Values[] = {
  enum1::field0,
  enum1::field1,
  enum1::field2
};

const char* _kenum1Names[] = {
  "field0",
  "field1",
  "field2"
};

const std::map<enum1, const char*> _enum1_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum1>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumIterator<enum1>(-1, nullptr, nullptr));
const std::map<const char*, enum1, apache::thrift::ltstr> _enum1_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum1>(3, _kenum1Values, _kenum1Names), apache::thrift::TEnumInverseIterator<enum1>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findName( ::test_cpp2::cpp_reflection::enum1 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum1_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum1>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum1* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum1_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum2 _kenum2Values[] = {
  enum2::field0_2,
  enum2::field1_2,
  enum2::field2_2
};

const char* _kenum2Names[] = {
  "field0_2",
  "field1_2",
  "field2_2"
};

const std::map<enum2, const char*> _enum2_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum2>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumIterator<enum2>(-1, nullptr, nullptr));
const std::map<const char*, enum2, apache::thrift::ltstr> _enum2_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum2>(3, _kenum2Values, _kenum2Names), apache::thrift::TEnumInverseIterator<enum2>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findName( ::test_cpp2::cpp_reflection::enum2 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum2_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum2>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum2* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum2_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

enum3 _kenum3Values[] = {
  enum3::field0_3,
  enum3::field1_3,
  enum3::field2_3
};

const char* _kenum3Names[] = {
  "field0_3",
  "field1_3",
  "field2_3"
};

const std::map<enum3, const char*> _enum3_VALUES_TO_NAMES(apache::thrift::TEnumIterator<enum3>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumIterator<enum3>(-1, nullptr, nullptr));
const std::map<const char*, enum3, apache::thrift::ltstr> _enum3_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<enum3>(3, _kenum3Values, _kenum3Names), apache::thrift::TEnumInverseIterator<enum3>(-1, nullptr, nullptr));

}} // test_cpp2::cpp_reflection
namespace std {

} // std
namespace apache { namespace thrift {

template <> const char* TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findName( ::test_cpp2::cpp_reflection::enum3 value) {
  return findName( ::test_cpp2::cpp_reflection::_enum3_VALUES_TO_NAMES, value);
}

template <> bool TEnumTraitsBase< ::test_cpp2::cpp_reflection::enum3>::findValue(const char* name,  ::test_cpp2::cpp_reflection::enum3* outValue) {
  return findValue( ::test_cpp2::cpp_reflection::_enum3_NAMES_TO_VALUES, name, outValue);
}

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union1::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union1::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui:
    {
      destruct(value_.ui);
      break;
    }
    case Type::ud:
    {
      destruct(value_.ud);
      break;
    }
    case Type::us:
    {
      destruct(value_.us);
      break;
    }
    case Type::ue:
    {
      destruct(value_.ue);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union1::operator==(const union1& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui:
    {
      return value_.ui == rhs.value_.ui;
      break;
    }
    case Type::ud:
    {
      return value_.ud == rhs.value_.ud;
      break;
    }
    case Type::us:
    {
      return value_.us == rhs.value_.us;
      break;
    }
    case Type::ue:
    {
      return value_.ue == rhs.value_.ue;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union2::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union2::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_2:
    {
      destruct(value_.ui_2);
      break;
    }
    case Type::ud_2:
    {
      destruct(value_.ud_2);
      break;
    }
    case Type::us_2:
    {
      destruct(value_.us_2);
      break;
    }
    case Type::ue_2:
    {
      destruct(value_.ue_2);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union2::operator==(const union2& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_2:
    {
      return value_.ui_2 == rhs.value_.ui_2;
      break;
    }
    case Type::ud_2:
    {
      return value_.ud_2 == rhs.value_.ud_2;
      break;
    }
    case Type::us_2:
    {
      return value_.us_2 == rhs.value_.us_2;
      break;
    }
    case Type::ue_2:
    {
      return value_.ue_2 == rhs.value_.ue_2;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t union3::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void union3::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::ui_3:
    {
      destruct(value_.ui_3);
      break;
    }
    case Type::ud_3:
    {
      destruct(value_.ud_3);
      break;
    }
    case Type::us_3:
    {
      destruct(value_.us_3);
      break;
    }
    case Type::ue_3:
    {
      destruct(value_.ue_3);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool union3::operator==(const union3& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::ui_3:
    {
      return value_.ui_3 == rhs.value_.ui_3;
      break;
    }
    case Type::ud_3:
    {
      return value_.ud_3 == rhs.value_.ud_3;
      break;
    }
    case Type::us_3:
    {
      return value_.us_3 == rhs.value_.us_3;
      break;
    }
    case Type::ue_3:
    {
      return value_.ue_3 == rhs.value_.ue_3;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t structA::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void structA::__clear() {
  a = 0;
  b = std::string();
  __isset.__clear();
}

bool structA::operator==(const structA& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  return true;
}

void swap(structA& a, structA& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t unionA::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void unionA::__clear() {
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::i:
    {
      destruct(value_.i);
      break;
    }
    case Type::d:
    {
      destruct(value_.d);
      break;
    }
    case Type::s:
    {
      destruct(value_.s);
      break;
    }
    case Type::e:
    {
      destruct(value_.e);
      break;
    }
    case Type::a:
    {
      destruct(value_.a);
      break;
    }
    default:
    {
      assert(false);
      break;
    }
  }
  type_ = Type::__EMPTY__;
}

bool unionA::operator==(const unionA& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::i:
    {
      return value_.i == rhs.value_.i;
      break;
    }
    case Type::d:
    {
      return value_.d == rhs.value_.d;
      break;
    }
    case Type::s:
    {
      return value_.s == rhs.value_.s;
      break;
    }
    case Type::e:
    {
      return value_.e == rhs.value_.e;
      break;
    }
    case Type::a:
    {
      return value_.a == rhs.value_.a;
      break;
    }
    default:
    {
      return true;
      break;
    }
  }
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t structB::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void structB::__clear() {
  c = 0;
  d = 0;
  __isset.__clear();
}

bool structB::operator==(const structB& rhs) const {
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  return true;
}

void swap(structB& a, structB& b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t structC::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void structC::__clear() {
  a = 0;
  b = std::string();
  c = 0;
  d = 0;
  e =  ::test_cpp2::cpp_reflection::enum1();
  f =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&g);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&h);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::unionA>::clear(&i);
  j.clear();
  j1.clear();
  j2.clear();
  j3.clear();
  k.clear();
  k1.clear();
  k2.clear();
  k3.clear();
  l.clear();
  l1.clear();
  l2.clear();
  l3.clear();
  m1.clear();
  m2.clear();
  m3.clear();
  n1.clear();
  n2.clear();
  n3.clear();
  o1.clear();
  o2.clear();
  o3.clear();
  __isset.__clear();
}

bool structC::operator==(const structC& rhs) const {
  if (!((a == rhs.a))) {
    return false;
  }
  if (!((b == rhs.b))) {
    return false;
  }
  if (!((c == rhs.c))) {
    return false;
  }
  if (!((d == rhs.d))) {
    return false;
  }
  if (!((e == rhs.e))) {
    return false;
  }
  if (!((f == rhs.f))) {
    return false;
  }
  if (!((g == rhs.g))) {
    return false;
  }
  if (!((h == rhs.h))) {
    return false;
  }
  if (!((i == rhs.i))) {
    return false;
  }
  if (!((j == rhs.j))) {
    return false;
  }
  if (!((j1 == rhs.j1))) {
    return false;
  }
  if (!((j2 == rhs.j2))) {
    return false;
  }
  if (!((j3 == rhs.j3))) {
    return false;
  }
  if (!((k == rhs.k))) {
    return false;
  }
  if (!((k1 == rhs.k1))) {
    return false;
  }
  if (!((k2 == rhs.k2))) {
    return false;
  }
  if (!((k3 == rhs.k3))) {
    return false;
  }
  if (!((l == rhs.l))) {
    return false;
  }
  if (!((l1 == rhs.l1))) {
    return false;
  }
  if (!((l2 == rhs.l2))) {
    return false;
  }
  if (!((l3 == rhs.l3))) {
    return false;
  }
  if (!((m1 == rhs.m1))) {
    return false;
  }
  if (!((m2 == rhs.m2))) {
    return false;
  }
  if (!((m3 == rhs.m3))) {
    return false;
  }
  if (!((n1 == rhs.n1))) {
    return false;
  }
  if (!((n2 == rhs.n2))) {
    return false;
  }
  if (!((n3 == rhs.n3))) {
    return false;
  }
  if (!((o1 == rhs.o1))) {
    return false;
  }
  if (!((o2 == rhs.o2))) {
    return false;
  }
  if (!((o3 == rhs.o3))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return g;
}

 ::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(g);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return h;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(h);
}

const  ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return i;
}

 ::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(i);
}

const std::vector<int32_t>& structC::get_j() const& {
  return j;
}

std::vector<int32_t> structC::get_j() && {
  return std::move(j);
}

const std::vector<int32_t>& structC::get_j1() const& {
  return j1;
}

std::vector<int32_t> structC::get_j1() && {
  return std::move(j1);
}

const std::vector< ::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return j2;
}

std::vector< ::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(j2);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return j3;
}

std::vector< ::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(j3);
}

const std::set<int32_t>& structC::get_k() const& {
  return k;
}

std::set<int32_t> structC::get_k() && {
  return std::move(k);
}

const std::set<int32_t>& structC::get_k1() const& {
  return k1;
}

std::set<int32_t> structC::get_k1() && {
  return std::move(k1);
}

const std::set< ::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return k2;
}

std::set< ::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(k2);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return k3;
}

std::set< ::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(k3);
}

const std::map<int32_t, int32_t>& structC::get_l() const& {
  return l;
}

std::map<int32_t, int32_t> structC::get_l() && {
  return std::move(l);
}

const std::map<int32_t, int32_t>& structC::get_l1() const& {
  return l1;
}

std::map<int32_t, int32_t> structC::get_l1() && {
  return std::move(l1);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return l2;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(l2);
}

const std::map<int32_t,  ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return l3;
}

std::map<int32_t,  ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(l3);
}

const std::map< ::test_cpp2::cpp_reflection::enum1, int32_t>& structC::get_m1() const& {
  return m1;
}

std::map< ::test_cpp2::cpp_reflection::enum1, int32_t> structC::get_m1() && {
  return std::move(m1);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return m2;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(m2);
}

const std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return m3;
}

std::map< ::test_cpp2::cpp_reflection::enum1,  ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(m3);
}

const std::map<std::string, int32_t>& structC::get_n1() const& {
  return n1;
}

std::map<std::string, int32_t> structC::get_n1() && {
  return std::move(n1);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return n2;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(n2);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return n3;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(n3);
}

const std::map< ::test_cpp2::cpp_reflection::structA, int32_t>& structC::get_o1() const& {
  return o1;
}

std::map< ::test_cpp2::cpp_reflection::structA, int32_t> structC::get_o1() && {
  return std::move(o1);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return o2;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(o2);
}

const std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return o3;
}

std::map< ::test_cpp2::cpp_reflection::structA,  ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(o3);
}

void swap(structC& a, structC& b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.b, b.b);
  swap(a.c, b.c);
  swap(a.d, b.d);
  swap(a.e, b.e);
  swap(a.f, b.f);
  swap(a.g, b.g);
  swap(a.h, b.h);
  swap(a.i, b.i);
  swap(a.j, b.j);
  swap(a.j1, b.j1);
  swap(a.j2, b.j2);
  swap(a.j3, b.j3);
  swap(a.k, b.k);
  swap(a.k1, b.k1);
  swap(a.k2, b.k2);
  swap(a.k3, b.k3);
  swap(a.l, b.l);
  swap(a.l1, b.l1);
  swap(a.l2, b.l2);
  swap(a.l3, b.l3);
  swap(a.m1, b.m1);
  swap(a.m2, b.m2);
  swap(a.m3, b.m3);
  swap(a.n1, b.n1);
  swap(a.n2, b.n2);
  swap(a.n3, b.n3);
  swap(a.o1, b.o1);
  swap(a.o2, b.o2);
  swap(a.o3, b.o3);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct1::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct1::__clear() {
  field0 = 0;
  field1 = std::string();
  field2 =  ::test_cpp2::cpp_reflection::enum1();
  field3 =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&field4);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&field5);
  __isset.__clear();
}

bool struct1::operator==(const struct1& rhs) const {
  if (!((field0 == rhs.field0))) {
    return false;
  }
  if (__isset.field1 != rhs.__isset.field1) {
    return false;
  }
  else if (__isset.field1 && !((field1 == rhs.field1))) {
    return false;
  }
  if (!((field2 == rhs.field2))) {
    return false;
  }
  if (!((field3 == rhs.field3))) {
    return false;
  }
  if (__isset.field4 != rhs.__isset.field4) {
    return false;
  }
  else if (__isset.field4 && !((field4 == rhs.field4))) {
    return false;
  }
  if (!((field5 == rhs.field5))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

 ::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return __isset.field4 ? std::addressof(field4) : nullptr;
}

const  ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return field5;
}

 ::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(field5);
}

void swap(struct1& a, struct1& b) {
  using ::std::swap;
  swap(a.field0, b.field0);
  swap(a.field1, b.field1);
  swap(a.field2, b.field2);
  swap(a.field3, b.field3);
  swap(a.field4, b.field4);
  swap(a.field5, b.field5);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct2::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct2::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  __isset.__clear();
}

bool struct2::operator==(const struct2& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(fieldG);
}

void swap(struct2& a, struct2& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

template uint32_t struct3::read<apache::thrift::BinaryProtocolReader>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSizeZC<apache::thrift::BinaryProtocolWriter>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::read<apache::thrift::CompactProtocolReader>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSizeZC<apache::thrift::CompactProtocolWriter>(apache::thrift::CompactProtocolWriter*) const;

void struct3::__clear() {
  fieldA = 0;
  fieldB = std::string();
  fieldC =  ::test_cpp2::cpp_reflection::enum1();
  fieldD =  ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union1>::clear(&fieldE);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldF);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::struct1>::clear(&fieldG);
  ::apache::thrift::Cpp2Ops<  ::test_cpp2::cpp_reflection::union2>::clear(&fieldH);
  fieldI.clear();
  fieldJ.clear();
  fieldK.clear();
  fieldL.clear();
  fieldM.clear();
  fieldN.clear();
  fieldO.clear();
  fieldP.clear();
  fieldQ.clear();
  fieldR.clear();
  __isset.__clear();
}

bool struct3::operator==(const struct3& rhs) const {
  if (!((fieldA == rhs.fieldA))) {
    return false;
  }
  if (!((fieldB == rhs.fieldB))) {
    return false;
  }
  if (!((fieldC == rhs.fieldC))) {
    return false;
  }
  if (!((fieldD == rhs.fieldD))) {
    return false;
  }
  if (!((fieldE == rhs.fieldE))) {
    return false;
  }
  if (!((fieldF == rhs.fieldF))) {
    return false;
  }
  if (!((fieldG == rhs.fieldG))) {
    return false;
  }
  if (!((fieldH == rhs.fieldH))) {
    return false;
  }
  if (!((fieldI == rhs.fieldI))) {
    return false;
  }
  if (!((fieldJ == rhs.fieldJ))) {
    return false;
  }
  if (!((fieldK == rhs.fieldK))) {
    return false;
  }
  if (!((fieldL == rhs.fieldL))) {
    return false;
  }
  if (!((fieldM == rhs.fieldM))) {
    return false;
  }
  if (!((fieldN == rhs.fieldN))) {
    return false;
  }
  if (!((fieldO == rhs.fieldO))) {
    return false;
  }
  if (!((fieldP == rhs.fieldP))) {
    return false;
  }
  if (!((fieldQ == rhs.fieldQ))) {
    return false;
  }
  if (!((fieldR == rhs.fieldR))) {
    return false;
  }
  return true;
}

const  ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return fieldE;
}

 ::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(fieldE);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return fieldF;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(fieldF);
}

const  ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return fieldG;
}

 ::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(fieldG);
}

const  ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return fieldH;
}

 ::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(fieldH);
}

const std::vector<int32_t>& struct3::get_fieldI() const& {
  return fieldI;
}

std::vector<int32_t> struct3::get_fieldI() && {
  return std::move(fieldI);
}

const std::vector<std::string>& struct3::get_fieldJ() const& {
  return fieldJ;
}

std::vector<std::string> struct3::get_fieldJ() && {
  return std::move(fieldJ);
}

const std::vector<std::string>& struct3::get_fieldK() const& {
  return fieldK;
}

std::vector<std::string> struct3::get_fieldK() && {
  return std::move(fieldK);
}

const std::vector< ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return fieldL;
}

std::vector< ::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(fieldL);
}

const std::set<int32_t>& struct3::get_fieldM() const& {
  return fieldM;
}

std::set<int32_t> struct3::get_fieldM() && {
  return std::move(fieldM);
}

const std::set<std::string>& struct3::get_fieldN() const& {
  return fieldN;
}

std::set<std::string> struct3::get_fieldN() && {
  return std::move(fieldN);
}

const std::set<std::string>& struct3::get_fieldO() const& {
  return fieldO;
}

std::set<std::string> struct3::get_fieldO() && {
  return std::move(fieldO);
}

const std::set< ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return fieldP;
}

std::set< ::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(fieldP);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return fieldQ;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(fieldQ);
}

const std::map<std::string,  ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return fieldR;
}

std::map<std::string,  ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(fieldR);
}

void swap(struct3& a, struct3& b) {
  using ::std::swap;
  swap(a.fieldA, b.fieldA);
  swap(a.fieldB, b.fieldB);
  swap(a.fieldC, b.fieldC);
  swap(a.fieldD, b.fieldD);
  swap(a.fieldE, b.fieldE);
  swap(a.fieldF, b.fieldF);
  swap(a.fieldG, b.fieldG);
  swap(a.fieldH, b.fieldH);
  swap(a.fieldI, b.fieldI);
  swap(a.fieldJ, b.fieldJ);
  swap(a.fieldK, b.fieldK);
  swap(a.fieldL, b.fieldL);
  swap(a.fieldM, b.fieldM);
  swap(a.fieldN, b.fieldN);
  swap(a.fieldO, b.fieldO);
  swap(a.fieldP, b.fieldP);
  swap(a.fieldQ, b.fieldQ);
  swap(a.fieldR, b.fieldR);
  swap(a.__isset, b.__isset);
}

}} // test_cpp2::cpp_reflection
namespace apache { namespace thrift {

}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

}} // test_cpp2::cpp_reflection