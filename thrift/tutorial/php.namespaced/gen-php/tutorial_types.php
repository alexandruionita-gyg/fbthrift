<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace tutorial;


/**
 * You can define enums, which are just 32 bit integers. Values are optional
 * and start at 1 if not supplied, C style again.
 */
final class Operation {
  const ADD = 1;
  const SUBTRACT = 2;
  const MULTIPLY = 3;
  const DIVIDE = 4;
  static public $__names = array(
    1 => 'ADD',
    2 => 'SUBTRACT',
    3 => 'MULTIPLY',
    4 => 'DIVIDE',
  );
  static public $__values = array(
    'ADD' => 1,
    'SUBTRACT' => 2,
    'MULTIPLY' => 3,
    'DIVIDE' => 4,
  );
}

$GLOBALS['E_Operation'] = Operation::$__values;

/**
 * Structs are the basic complex data structures. They are comprised of fields
 * which each have an integer identifier, a type, a symbolic name, and an
 * optional default value.
 * 
 * Fields can be declared "optional", which ensures they will not be included
 * in the serialized output if they aren't set.  Note that this requires some
 * manual management in some languages.
 */
class Work implements \IThriftStruct {
  static $_TSPEC = array(
    1 => array(
      'var' => 'num1',
      'type' => \TType::I32,
      ),
    2 => array(
      'var' => 'num2',
      'type' => \TType::I32,
      ),
    3 => array(
      'var' => 'op',
      'type' => \TType::I32,
      'enum' => 'Operation',
      ),
    4 => array(
      'var' => 'comment',
      'type' => \TType::STRING,
      ),
    );
  public static $_TFIELDMAP = array(
    'num1' => 1,
    'num2' => 2,
    'op' => 3,
    'comment' => 4,
  );
  const STRUCTURAL_ID = 1459638676176566529;
  public $num1 = 0;
  public $num2 = null;
  public $op = null;
  public $comment = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['num1'])) {
        $this->num1 = $vals['num1'];
      }
      if (isset($vals['num2'])) {
        $this->num2 = $vals['num2'];
      }
      if (isset($vals['op'])) {
        $this->op = $vals['op'];
      }
      if (isset($vals['comment'])) {
        $this->comment = $vals['comment'];
      }
    } else if ($vals) {
      throw new \TProtocolException(
        'Work constructor must be passed array or null'
      );
    }
  }

  public function getName() {
    return 'Work';
  }

  public static function __set_state($vals) {
    return new Work($vals);
  }

  public function read(\TProtocol $input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        if (isset(self::$_TFIELDMAP[$fname])) {
          $fid = self::$_TFIELDMAP[$fname];
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::I32) {
            $xfer += $input->readI32($this->num1);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == \TType::I32) {
            $xfer += $input->readI32($this->num2);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == \TType::I32) {
            $xfer += $input->readI32($this->op);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString($this->comment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Work');
    if ($this->num1 !== null) {
      $xfer += $output->writeFieldBegin('num1', \TType::I32, 1);
      $xfer += $output->writeI32($this->num1);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->num2 !== null) {
      $xfer += $output->writeFieldBegin('num2', \TType::I32, 2);
      $xfer += $output->writeI32($this->num2);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->op !== null) {
      $xfer += $output->writeFieldBegin('op', \TType::I32, 3);
      $xfer += $output->writeI32($this->op);
      $xfer += $output->writeFieldEnd();
    }
    if (isset($this->comment) && $this->comment !== null) {
      $xfer += $output->writeFieldBegin('comment', \TType::STRING, 4);
      $xfer += $output->writeString($this->comment);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Structs can also be exceptions, if they are nasty.
 */
class InvalidOperation extends \TException implements \IThriftStruct {
  static $_TSPEC = array(
    1 => array(
      'var' => 'op',
      'type' => \TType::I32,
      'enum' => 'Operation',
      ),
    2 => array(
      'var' => 'why',
      'type' => \TType::STRING,
      ),
    );
  public static $_TFIELDMAP = array(
    'op' => 1,
    'why' => 2,
  );
  const STRUCTURAL_ID = 5833490447732221616;
  public $op = null;
  public $why = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['op'])) {
        $this->op = $vals['op'];
      }
      if (isset($vals['why'])) {
        $this->why = $vals['why'];
      }
    } else if ($vals) {
      throw new \TProtocolException(
        'InvalidOperation constructor must be passed array or null'
      );
    }
  }

  public function getName() {
    return 'InvalidOperation';
  }

  public static function __set_state($vals) {
    return new InvalidOperation($vals);
  }

  public function read(\TProtocol $input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == \TType::STOP) {
        break;
      }
      if (!$fid && $fname !== null) {
        if (isset(self::$_TFIELDMAP[$fname])) {
          $fid = self::$_TFIELDMAP[$fname];
          $ftype = self::$_TSPEC[$fid]['type'];
        }
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == \TType::I32) {
            $xfer += $input->readI32($this->op);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == \TType::STRING) {
            $xfer += $input->readString($this->why);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write(\TProtocol $output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('InvalidOperation');
    if ($this->op !== null) {
      $xfer += $output->writeFieldBegin('op', \TType::I32, 1);
      $xfer += $output->writeI32($this->op);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->why !== null) {
      $xfer += $output->writeFieldBegin('why', \TType::STRING, 2);
      $xfer += $output->writeString($this->why);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
